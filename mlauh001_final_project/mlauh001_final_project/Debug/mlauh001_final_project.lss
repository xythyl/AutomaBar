
mlauh001_final_project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000a2  00800100  0000131a  000013ae  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000131a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000654  008001a2  008001a2  00001450  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001450  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001480  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000260  00000000  00000000  000014c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002539  00000000  00000000  00001720  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000993  00000000  00000000  00003c59  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000186d  00000000  00000000  000045ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000005dc  00000000  00000000  00005e5c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000eb0  00000000  00000000  00006438  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000015a9  00000000  00000000  000072e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000258  00000000  00000000  00008891  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
       2:	00 00       	nop
       4:	61 c0       	rjmp	.+194    	; 0xc8 <__bad_interrupt>
       6:	00 00       	nop
       8:	5f c0       	rjmp	.+190    	; 0xc8 <__bad_interrupt>
       a:	00 00       	nop
       c:	5d c0       	rjmp	.+186    	; 0xc8 <__bad_interrupt>
       e:	00 00       	nop
      10:	5b c0       	rjmp	.+182    	; 0xc8 <__bad_interrupt>
      12:	00 00       	nop
      14:	59 c0       	rjmp	.+178    	; 0xc8 <__bad_interrupt>
      16:	00 00       	nop
      18:	57 c0       	rjmp	.+174    	; 0xc8 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	55 c0       	rjmp	.+170    	; 0xc8 <__bad_interrupt>
      1e:	00 00       	nop
      20:	53 c0       	rjmp	.+166    	; 0xc8 <__bad_interrupt>
      22:	00 00       	nop
      24:	51 c0       	rjmp	.+162    	; 0xc8 <__bad_interrupt>
      26:	00 00       	nop
      28:	4f c0       	rjmp	.+158    	; 0xc8 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	4d c0       	rjmp	.+154    	; 0xc8 <__bad_interrupt>
      2e:	00 00       	nop
      30:	4b c0       	rjmp	.+150    	; 0xc8 <__bad_interrupt>
      32:	00 00       	nop
      34:	f4 c5       	rjmp	.+3048   	; 0xc1e <__vector_13>
      36:	00 00       	nop
      38:	47 c0       	rjmp	.+142    	; 0xc8 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	45 c0       	rjmp	.+138    	; 0xc8 <__bad_interrupt>
      3e:	00 00       	nop
      40:	43 c0       	rjmp	.+134    	; 0xc8 <__bad_interrupt>
      42:	00 00       	nop
      44:	41 c0       	rjmp	.+130    	; 0xc8 <__bad_interrupt>
      46:	00 00       	nop
      48:	3f c0       	rjmp	.+126    	; 0xc8 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	3d c0       	rjmp	.+122    	; 0xc8 <__bad_interrupt>
      4e:	00 00       	nop
      50:	3b c0       	rjmp	.+118    	; 0xc8 <__bad_interrupt>
      52:	00 00       	nop
      54:	39 c0       	rjmp	.+114    	; 0xc8 <__bad_interrupt>
      56:	00 00       	nop
      58:	37 c0       	rjmp	.+110    	; 0xc8 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	35 c0       	rjmp	.+106    	; 0xc8 <__bad_interrupt>
      5e:	00 00       	nop
      60:	33 c0       	rjmp	.+102    	; 0xc8 <__bad_interrupt>
      62:	00 00       	nop
      64:	31 c0       	rjmp	.+98     	; 0xc8 <__bad_interrupt>
      66:	00 00       	nop
      68:	2f c0       	rjmp	.+94     	; 0xc8 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	2d c0       	rjmp	.+90     	; 0xc8 <__bad_interrupt>
      6e:	00 00       	nop
      70:	2b c0       	rjmp	.+86     	; 0xc8 <__bad_interrupt>
      72:	00 00       	nop
      74:	29 c0       	rjmp	.+82     	; 0xc8 <__bad_interrupt>
      76:	00 00       	nop
      78:	27 c0       	rjmp	.+78     	; 0xc8 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	25 c0       	rjmp	.+74     	; 0xc8 <__bad_interrupt>
      7e:	00 00       	nop
      80:	23 c0       	rjmp	.+70     	; 0xc8 <__bad_interrupt>
      82:	00 00       	nop
      84:	21 c0       	rjmp	.+66     	; 0xc8 <__bad_interrupt>
      86:	00 00       	nop
      88:	1f c0       	rjmp	.+62     	; 0xc8 <__bad_interrupt>
	...

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e4       	ldi	r29, 0x40	; 64
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	ea e1       	ldi	r30, 0x1A	; 26
      a0:	f3 e1       	ldi	r31, 0x13	; 19
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	a2 3a       	cpi	r26, 0xA2	; 162
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	27 e0       	ldi	r18, 0x07	; 7
      b4:	a2 ea       	ldi	r26, 0xA2	; 162
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a6 3f       	cpi	r26, 0xF6	; 246
      be:	b2 07       	cpc	r27, r18
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	45 d4       	rcall	.+2186   	; 0x94e <main>
      c4:	0c 94 8b 09 	jmp	0x1316	; 0x1316 <_exit>

000000c8 <__bad_interrupt>:
      c8:	9b cf       	rjmp	.-202    	; 0x0 <__vectors>

000000ca <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
      ca:	cf 93       	push	r28
      cc:	df 93       	push	r29
      ce:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
      d0:	f9 d6       	rcall	.+3570   	; 0xec4 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
      d2:	20 91 a2 01 	lds	r18, 0x01A2	; 0x8001a2 <__data_end>
      d6:	30 91 a3 01 	lds	r19, 0x01A3	; 0x8001a3 <__data_end+0x1>
      da:	ce 01       	movw	r24, r28
      dc:	82 0f       	add	r24, r18
      de:	93 1f       	adc	r25, r19
      e0:	8c 3d       	cpi	r24, 0xDC	; 220
      e2:	45 e0       	ldi	r20, 0x05	; 5
      e4:	94 07       	cpc	r25, r20
      e6:	58 f4       	brcc	.+22     	; 0xfe <pvPortMalloc+0x34>
      e8:	28 17       	cp	r18, r24
      ea:	39 07       	cpc	r19, r25
      ec:	58 f4       	brcc	.+22     	; 0x104 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
      ee:	e9 01       	movw	r28, r18
      f0:	cc 55       	subi	r28, 0x5C	; 92
      f2:	de 4f       	sbci	r29, 0xFE	; 254
			xNextFreeByte += xWantedSize;			
      f4:	90 93 a3 01 	sts	0x01A3, r25	; 0x8001a3 <__data_end+0x1>
      f8:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <__data_end>
      fc:	05 c0       	rjmp	.+10     	; 0x108 <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
      fe:	c0 e0       	ldi	r28, 0x00	; 0
     100:	d0 e0       	ldi	r29, 0x00	; 0
     102:	02 c0       	rjmp	.+4      	; 0x108 <pvPortMalloc+0x3e>
     104:	c0 e0       	ldi	r28, 0x00	; 0
     106:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     108:	a4 d7       	rcall	.+3912   	; 0x1052 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     10a:	ce 01       	movw	r24, r28
     10c:	df 91       	pop	r29
     10e:	cf 91       	pop	r28
     110:	08 95       	ret

00000112 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     112:	08 95       	ret

00000114 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     114:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     116:	03 96       	adiw	r24, 0x03	; 3
     118:	92 83       	std	Z+2, r25	; 0x02
     11a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     11c:	2f ef       	ldi	r18, 0xFF	; 255
     11e:	3f ef       	ldi	r19, 0xFF	; 255
     120:	34 83       	std	Z+4, r19	; 0x04
     122:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     124:	96 83       	std	Z+6, r25	; 0x06
     126:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     128:	90 87       	std	Z+8, r25	; 0x08
     12a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     12c:	10 82       	st	Z, r1
     12e:	08 95       	ret

00000130 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     130:	fc 01       	movw	r30, r24
     132:	11 86       	std	Z+9, r1	; 0x09
     134:	10 86       	std	Z+8, r1	; 0x08
     136:	08 95       	ret

00000138 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     138:	cf 93       	push	r28
     13a:	df 93       	push	r29
     13c:	fc 01       	movw	r30, r24
     13e:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     140:	21 81       	ldd	r18, Z+1	; 0x01
     142:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     144:	e9 01       	movw	r28, r18
     146:	8a 81       	ldd	r24, Y+2	; 0x02
     148:	9b 81       	ldd	r25, Y+3	; 0x03
     14a:	13 96       	adiw	r26, 0x03	; 3
     14c:	9c 93       	st	X, r25
     14e:	8e 93       	st	-X, r24
     150:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     152:	81 81       	ldd	r24, Z+1	; 0x01
     154:	92 81       	ldd	r25, Z+2	; 0x02
     156:	15 96       	adiw	r26, 0x05	; 5
     158:	9c 93       	st	X, r25
     15a:	8e 93       	st	-X, r24
     15c:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     15e:	8a 81       	ldd	r24, Y+2	; 0x02
     160:	9b 81       	ldd	r25, Y+3	; 0x03
     162:	ec 01       	movw	r28, r24
     164:	7d 83       	std	Y+5, r23	; 0x05
     166:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     168:	e9 01       	movw	r28, r18
     16a:	7b 83       	std	Y+3, r23	; 0x03
     16c:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     16e:	72 83       	std	Z+2, r23	; 0x02
     170:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     172:	19 96       	adiw	r26, 0x09	; 9
     174:	fc 93       	st	X, r31
     176:	ee 93       	st	-X, r30
     178:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     17a:	80 81       	ld	r24, Z
     17c:	8f 5f       	subi	r24, 0xFF	; 255
     17e:	80 83       	st	Z, r24
}
     180:	df 91       	pop	r29
     182:	cf 91       	pop	r28
     184:	08 95       	ret

00000186 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     186:	cf 93       	push	r28
     188:	df 93       	push	r29
     18a:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     18c:	48 81       	ld	r20, Y
     18e:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     190:	4f 3f       	cpi	r20, 0xFF	; 255
     192:	2f ef       	ldi	r18, 0xFF	; 255
     194:	52 07       	cpc	r21, r18
     196:	31 f4       	brne	.+12     	; 0x1a4 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     198:	dc 01       	movw	r26, r24
     19a:	17 96       	adiw	r26, 0x07	; 7
     19c:	ed 91       	ld	r30, X+
     19e:	fc 91       	ld	r31, X
     1a0:	18 97       	sbiw	r26, 0x08	; 8
     1a2:	17 c0       	rjmp	.+46     	; 0x1d2 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     1a4:	fc 01       	movw	r30, r24
     1a6:	33 96       	adiw	r30, 0x03	; 3
     1a8:	dc 01       	movw	r26, r24
     1aa:	15 96       	adiw	r26, 0x05	; 5
     1ac:	2d 91       	ld	r18, X+
     1ae:	3c 91       	ld	r19, X
     1b0:	16 97       	sbiw	r26, 0x06	; 6
     1b2:	d9 01       	movw	r26, r18
     1b4:	2d 91       	ld	r18, X+
     1b6:	3c 91       	ld	r19, X
     1b8:	42 17       	cp	r20, r18
     1ba:	53 07       	cpc	r21, r19
     1bc:	50 f0       	brcs	.+20     	; 0x1d2 <vListInsert+0x4c>
     1be:	02 80       	ldd	r0, Z+2	; 0x02
     1c0:	f3 81       	ldd	r31, Z+3	; 0x03
     1c2:	e0 2d       	mov	r30, r0
     1c4:	a2 81       	ldd	r26, Z+2	; 0x02
     1c6:	b3 81       	ldd	r27, Z+3	; 0x03
     1c8:	2d 91       	ld	r18, X+
     1ca:	3c 91       	ld	r19, X
     1cc:	42 17       	cp	r20, r18
     1ce:	53 07       	cpc	r21, r19
     1d0:	b0 f7       	brcc	.-20     	; 0x1be <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     1d2:	a2 81       	ldd	r26, Z+2	; 0x02
     1d4:	b3 81       	ldd	r27, Z+3	; 0x03
     1d6:	bb 83       	std	Y+3, r27	; 0x03
     1d8:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     1da:	15 96       	adiw	r26, 0x05	; 5
     1dc:	dc 93       	st	X, r29
     1de:	ce 93       	st	-X, r28
     1e0:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     1e2:	fd 83       	std	Y+5, r31	; 0x05
     1e4:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     1e6:	d3 83       	std	Z+3, r29	; 0x03
     1e8:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     1ea:	99 87       	std	Y+9, r25	; 0x09
     1ec:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     1ee:	fc 01       	movw	r30, r24
     1f0:	20 81       	ld	r18, Z
     1f2:	2f 5f       	subi	r18, 0xFF	; 255
     1f4:	20 83       	st	Z, r18
}
     1f6:	df 91       	pop	r29
     1f8:	cf 91       	pop	r28
     1fa:	08 95       	ret

000001fc <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     1fc:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     1fe:	a2 81       	ldd	r26, Z+2	; 0x02
     200:	b3 81       	ldd	r27, Z+3	; 0x03
     202:	84 81       	ldd	r24, Z+4	; 0x04
     204:	95 81       	ldd	r25, Z+5	; 0x05
     206:	15 96       	adiw	r26, 0x05	; 5
     208:	9c 93       	st	X, r25
     20a:	8e 93       	st	-X, r24
     20c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     20e:	a4 81       	ldd	r26, Z+4	; 0x04
     210:	b5 81       	ldd	r27, Z+5	; 0x05
     212:	82 81       	ldd	r24, Z+2	; 0x02
     214:	93 81       	ldd	r25, Z+3	; 0x03
     216:	13 96       	adiw	r26, 0x03	; 3
     218:	9c 93       	st	X, r25
     21a:	8e 93       	st	-X, r24
     21c:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     21e:	a0 85       	ldd	r26, Z+8	; 0x08
     220:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     222:	11 96       	adiw	r26, 0x01	; 1
     224:	8d 91       	ld	r24, X+
     226:	9c 91       	ld	r25, X
     228:	12 97       	sbiw	r26, 0x02	; 2
     22a:	8e 17       	cp	r24, r30
     22c:	9f 07       	cpc	r25, r31
     22e:	31 f4       	brne	.+12     	; 0x23c <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     230:	84 81       	ldd	r24, Z+4	; 0x04
     232:	95 81       	ldd	r25, Z+5	; 0x05
     234:	12 96       	adiw	r26, 0x02	; 2
     236:	9c 93       	st	X, r25
     238:	8e 93       	st	-X, r24
     23a:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     23c:	11 86       	std	Z+9, r1	; 0x09
     23e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     240:	8c 91       	ld	r24, X
     242:	81 50       	subi	r24, 0x01	; 1
     244:	8c 93       	st	X, r24
     246:	08 95       	ret

00000248 <initUSART>:
void PollUSART_Init() {
	poll_usart_state = PollUSART_INIT;
}

void MakeDrink_Init() {
	make_drink_state = MakeDrink_INIT;
     248:	81 30       	cpi	r24, 0x01	; 1
     24a:	81 f0       	breq	.+32     	; 0x26c <initUSART+0x24>
     24c:	e1 ec       	ldi	r30, 0xC1	; 193
     24e:	f0 e0       	ldi	r31, 0x00	; 0
     250:	80 81       	ld	r24, Z
     252:	88 61       	ori	r24, 0x18	; 24
     254:	80 83       	st	Z, r24
     256:	e2 ec       	ldi	r30, 0xC2	; 194
     258:	f0 e0       	ldi	r31, 0x00	; 0
     25a:	80 81       	ld	r24, Z
     25c:	86 60       	ori	r24, 0x06	; 6
     25e:	80 83       	st	Z, r24
     260:	83 e3       	ldi	r24, 0x33	; 51
     262:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
     266:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
     26a:	08 95       	ret
     26c:	e9 ec       	ldi	r30, 0xC9	; 201
     26e:	f0 e0       	ldi	r31, 0x00	; 0
     270:	80 81       	ld	r24, Z
     272:	88 61       	ori	r24, 0x18	; 24
     274:	80 83       	st	Z, r24
     276:	ea ec       	ldi	r30, 0xCA	; 202
     278:	f0 e0       	ldi	r31, 0x00	; 0
     27a:	80 81       	ld	r24, Z
     27c:	86 60       	ori	r24, 0x06	; 6
     27e:	80 83       	st	Z, r24
     280:	83 e3       	ldi	r24, 0x33	; 51
     282:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7e00cc>
     286:	10 92 cd 00 	sts	0x00CD, r1	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7e00cd>
     28a:	08 95       	ret

0000028c <USART_Flush>:
     28c:	81 30       	cpi	r24, 0x01	; 1
     28e:	29 f4       	brne	.+10     	; 0x29a <USART_Flush+0xe>
     290:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7e00c8>
     294:	88 23       	and	r24, r24
     296:	84 f0       	brlt	.+32     	; 0x2b8 <USART_Flush+0x2c>
     298:	08 95       	ret
     29a:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     29e:	88 23       	and	r24, r24
     2a0:	ac f4       	brge	.+42     	; 0x2cc <USART_Flush+0x40>
     2a2:	a6 ec       	ldi	r26, 0xC6	; 198
     2a4:	b0 e0       	ldi	r27, 0x00	; 0
     2a6:	e0 ec       	ldi	r30, 0xC0	; 192
     2a8:	f0 e0       	ldi	r31, 0x00	; 0
     2aa:	8c 91       	ld	r24, X
     2ac:	80 93 80 07 	sts	0x0780, r24	; 0x800780 <dummy.2320>
     2b0:	80 81       	ld	r24, Z
     2b2:	88 23       	and	r24, r24
     2b4:	d4 f3       	brlt	.-12     	; 0x2aa <USART_Flush+0x1e>
     2b6:	08 95       	ret
     2b8:	ae ec       	ldi	r26, 0xCE	; 206
     2ba:	b0 e0       	ldi	r27, 0x00	; 0
     2bc:	e8 ec       	ldi	r30, 0xC8	; 200
     2be:	f0 e0       	ldi	r31, 0x00	; 0
     2c0:	8c 91       	ld	r24, X
     2c2:	80 93 80 07 	sts	0x0780, r24	; 0x800780 <dummy.2320>
     2c6:	80 81       	ld	r24, Z
     2c8:	88 23       	and	r24, r24
     2ca:	d4 f3       	brlt	.-12     	; 0x2c0 <USART_Flush+0x34>
     2cc:	08 95       	ret

000002ce <USART_Send>:
     2ce:	61 30       	cpi	r22, 0x01	; 1
     2d0:	41 f0       	breq	.+16     	; 0x2e2 <USART_Send+0x14>
     2d2:	e0 ec       	ldi	r30, 0xC0	; 192
     2d4:	f0 e0       	ldi	r31, 0x00	; 0
     2d6:	90 81       	ld	r25, Z
     2d8:	95 ff       	sbrs	r25, 5
     2da:	fd cf       	rjmp	.-6      	; 0x2d6 <USART_Send+0x8>
     2dc:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     2e0:	08 95       	ret
     2e2:	e8 ec       	ldi	r30, 0xC8	; 200
     2e4:	f0 e0       	ldi	r31, 0x00	; 0
     2e6:	90 81       	ld	r25, Z
     2e8:	95 ff       	sbrs	r25, 5
     2ea:	fd cf       	rjmp	.-6      	; 0x2e6 <USART_Send+0x18>
     2ec:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
     2f0:	08 95       	ret

000002f2 <USART_Receive>:
     2f2:	81 30       	cpi	r24, 0x01	; 1
     2f4:	41 f0       	breq	.+16     	; 0x306 <USART_Receive+0x14>
     2f6:	e0 ec       	ldi	r30, 0xC0	; 192
     2f8:	f0 e0       	ldi	r31, 0x00	; 0
     2fa:	80 81       	ld	r24, Z
     2fc:	88 23       	and	r24, r24
     2fe:	ec f7       	brge	.-6      	; 0x2fa <USART_Receive+0x8>
     300:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     304:	08 95       	ret
     306:	e8 ec       	ldi	r30, 0xC8	; 200
     308:	f0 e0       	ldi	r31, 0x00	; 0
     30a:	80 81       	ld	r24, Z
     30c:	88 23       	and	r24, r24
     30e:	ec f7       	brge	.-6      	; 0x30a <USART_Receive+0x18>
     310:	80 91 ce 00 	lds	r24, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
     314:	08 95       	ret

00000316 <USART_Send_String>:
     316:	ff 92       	push	r15
     318:	0f 93       	push	r16
     31a:	1f 93       	push	r17
     31c:	cf 93       	push	r28
     31e:	df 93       	push	r29
     320:	06 2f       	mov	r16, r22
     322:	fc 01       	movw	r30, r24
     324:	01 90       	ld	r0, Z+
     326:	00 20       	and	r0, r0
     328:	e9 f7       	brne	.-6      	; 0x324 <USART_Send_String+0xe>
     32a:	31 97       	sbiw	r30, 0x01	; 1
     32c:	1e 2f       	mov	r17, r30
     32e:	18 1b       	sub	r17, r24
     330:	51 f0       	breq	.+20     	; 0x346 <USART_Send_String+0x30>
     332:	f8 2e       	mov	r15, r24
     334:	c8 2f       	mov	r28, r24
     336:	d9 2f       	mov	r29, r25
     338:	60 2f       	mov	r22, r16
     33a:	89 91       	ld	r24, Y+
     33c:	c8 df       	rcall	.-112    	; 0x2ce <USART_Send>
     33e:	8c 2f       	mov	r24, r28
     340:	8f 19       	sub	r24, r15
     342:	81 17       	cp	r24, r17
     344:	c8 f3       	brcs	.-14     	; 0x338 <USART_Send_String+0x22>
     346:	60 2f       	mov	r22, r16
     348:	8f ef       	ldi	r24, 0xFF	; 255
     34a:	c1 df       	rcall	.-126    	; 0x2ce <USART_Send>
     34c:	60 2f       	mov	r22, r16
     34e:	8f ef       	ldi	r24, 0xFF	; 255
     350:	be df       	rcall	.-132    	; 0x2ce <USART_Send>
     352:	60 2f       	mov	r22, r16
     354:	8f ef       	ldi	r24, 0xFF	; 255
     356:	bb df       	rcall	.-138    	; 0x2ce <USART_Send>
     358:	df 91       	pop	r29
     35a:	cf 91       	pop	r28
     35c:	1f 91       	pop	r17
     35e:	0f 91       	pop	r16
     360:	ff 90       	pop	r15
     362:	08 95       	ret

00000364 <Rotate_Tick>:
}

void Rotate_Tick(){
	//USART_Send_String("page page1",0);
	//Actions
	switch(rotate_state){
     364:	80 91 f1 07 	lds	r24, 0x07F1	; 0x8007f1 <rotate_state>
     368:	81 30       	cpi	r24, 0x01	; 1
     36a:	49 f0       	breq	.+18     	; 0x37e <Rotate_Tick+0x1a>
     36c:	18 f0       	brcs	.+6      	; 0x374 <Rotate_Tick+0x10>
     36e:	82 30       	cpi	r24, 0x02	; 2
     370:	91 f0       	breq	.+36     	; 0x396 <Rotate_Tick+0x32>
     372:	4c c0       	rjmp	.+152    	; 0x40c <__FUSE_REGION_LENGTH__+0xc>
		case Rotate_INIT:
			//PORTA = 0;
			rotate_stepper = 0;
     374:	10 92 8d 07 	sts	0x078D, r1	; 0x80078d <rotate_stepper>
			current_position = 0;
     378:	10 92 92 07 	sts	0x0792, r1	; 0x800792 <current_position>
     37c:	50 c0       	rjmp	.+160    	; 0x41e <__FUSE_REGION_LENGTH__+0x1e>
			break;
		case Rotate_Wait:
			cnt = 0; //index in list of steps
     37e:	10 92 95 07 	sts	0x0795, r1	; 0x800795 <cnt>
			total_cnt = 0; //count of total number of steps
     382:	10 92 94 07 	sts	0x0794, r1	; 0x800794 <total_cnt+0x1>
     386:	10 92 93 07 	sts	0x0793, r1	; 0x800793 <total_cnt>
			//drink = 0; //drink selected
			drink_select = ~PINB & 0x3F;
     38a:	83 b1       	in	r24, 0x03	; 3
     38c:	80 95       	com	r24
     38e:	8f 73       	andi	r24, 0x3F	; 63
     390:	80 93 8e 07 	sts	0x078E, r24	; 0x80078e <drink_select>
     394:	48 c0       	rjmp	.+144    	; 0x426 <__FUSE_REGION_LENGTH__+0x26>
				//USART_Send_String(lcd_str,1);
			}
			*/
			break;
		case go_to_drink:
			if (current_position < drink) {
     396:	90 91 92 07 	lds	r25, 0x0792	; 0x800792 <current_position>
     39a:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <drink>
     39e:	98 17       	cp	r25, r24
     3a0:	c8 f4       	brcc	.+50     	; 0x3d4 <Rotate_Tick+0x70>
					//forward	
					//PORTA = forward_steps[cnt++];
					rotate_stepper = forward_steps[cnt++];
     3a2:	80 91 95 07 	lds	r24, 0x0795	; 0x800795 <cnt>
     3a6:	e8 2f       	mov	r30, r24
     3a8:	f0 e0       	ldi	r31, 0x00	; 0
     3aa:	e2 5d       	subi	r30, 0xD2	; 210
     3ac:	fe 4f       	sbci	r31, 0xFE	; 254
     3ae:	90 81       	ld	r25, Z
     3b0:	90 93 8d 07 	sts	0x078D, r25	; 0x80078d <rotate_stepper>
     3b4:	8f 5f       	subi	r24, 0xFF	; 255
					cnt %= num_steps;
     3b6:	60 91 29 01 	lds	r22, 0x0129	; 0x800129 <num_steps>
     3ba:	8b d7       	rcall	.+3862   	; 0x12d2 <__udivmodqi4>
     3bc:	90 93 95 07 	sts	0x0795, r25	; 0x800795 <cnt>
					total_cnt++;
     3c0:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <total_cnt>
     3c4:	90 91 94 07 	lds	r25, 0x0794	; 0x800794 <total_cnt+0x1>
     3c8:	01 96       	adiw	r24, 0x01	; 1
     3ca:	90 93 94 07 	sts	0x0794, r25	; 0x800794 <total_cnt+0x1>
     3ce:	80 93 93 07 	sts	0x0793, r24	; 0x800793 <total_cnt>
     3d2:	8f c0       	rjmp	.+286    	; 0x4f2 <__FUSE_REGION_LENGTH__+0xf2>
			}	
			else if (current_position > drink) {
     3d4:	89 17       	cp	r24, r25
     3d6:	08 f0       	brcs	.+2      	; 0x3da <Rotate_Tick+0x76>
     3d8:	8c c0       	rjmp	.+280    	; 0x4f2 <__FUSE_REGION_LENGTH__+0xf2>
					//backward
					//PORTA = backward_steps[cnt++];
					rotate_stepper = backward_steps[cnt++];
     3da:	80 91 95 07 	lds	r24, 0x0795	; 0x800795 <cnt>
     3de:	e8 2f       	mov	r30, r24
     3e0:	f0 e0       	ldi	r31, 0x00	; 0
     3e2:	e6 5d       	subi	r30, 0xD6	; 214
     3e4:	fe 4f       	sbci	r31, 0xFE	; 254
     3e6:	90 81       	ld	r25, Z
     3e8:	90 93 8d 07 	sts	0x078D, r25	; 0x80078d <rotate_stepper>
     3ec:	8f 5f       	subi	r24, 0xFF	; 255
					cnt %= num_steps;
     3ee:	60 91 29 01 	lds	r22, 0x0129	; 0x800129 <num_steps>
     3f2:	6f d7       	rcall	.+3806   	; 0x12d2 <__udivmodqi4>
     3f4:	90 93 95 07 	sts	0x0795, r25	; 0x800795 <cnt>
					total_cnt++;
     3f8:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <total_cnt>
     3fc:	90 91 94 07 	lds	r25, 0x0794	; 0x800794 <total_cnt+0x1>
     400:	01 96       	adiw	r24, 0x01	; 1
     402:	90 93 94 07 	sts	0x0794, r25	; 0x800794 <total_cnt+0x1>
     406:	80 93 93 07 	sts	0x0793, r24	; 0x800793 <total_cnt>
     40a:	73 c0       	rjmp	.+230    	; 0x4f2 <__FUSE_REGION_LENGTH__+0xf2>
			}
			break;
		default:
			//PORTA = 0;
			rotate_stepper = 0;
     40c:	10 92 8d 07 	sts	0x078D, r1	; 0x80078d <rotate_stepper>
			break;
	}

	//Transitions
	//----------------------------
	switch(rotate_state){
     410:	81 30       	cpi	r24, 0x01	; 1
     412:	49 f0       	breq	.+18     	; 0x426 <__FUSE_REGION_LENGTH__+0x26>
     414:	20 f0       	brcs	.+8      	; 0x41e <__FUSE_REGION_LENGTH__+0x1e>
     416:	82 30       	cpi	r24, 0x02	; 2
     418:	09 f0       	breq	.+2      	; 0x41c <__FUSE_REGION_LENGTH__+0x1c>
     41a:	84 c0       	rjmp	.+264    	; 0x524 <__FUSE_REGION_LENGTH__+0x124>
     41c:	6a c0       	rjmp	.+212    	; 0x4f2 <__FUSE_REGION_LENGTH__+0xf2>
		case Rotate_INIT:
			rotate_state = Rotate_Wait;
     41e:	81 e0       	ldi	r24, 0x01	; 1
     420:	80 93 f1 07 	sts	0x07F1, r24	; 0x8007f1 <rotate_state>
			break;
     424:	08 95       	ret
		case Rotate_Wait:
			if (drink_select) {
     426:	80 91 8e 07 	lds	r24, 0x078E	; 0x80078e <drink_select>
     42a:	88 23       	and	r24, r24
     42c:	e9 f1       	breq	.+122    	; 0x4a8 <__FUSE_REGION_LENGTH__+0xa8>
				if (drink_select == 0x01) { drink = 0;}
     42e:	81 30       	cpi	r24, 0x01	; 1
     430:	19 f4       	brne	.+6      	; 0x438 <__FUSE_REGION_LENGTH__+0x38>
     432:	10 92 8f 07 	sts	0x078F, r1	; 0x80078f <drink>
     436:	1d c0       	rjmp	.+58     	; 0x472 <__FUSE_REGION_LENGTH__+0x72>
				else if (drink_select == 0x02) { drink = 1;}
     438:	82 30       	cpi	r24, 0x02	; 2
     43a:	21 f4       	brne	.+8      	; 0x444 <__FUSE_REGION_LENGTH__+0x44>
     43c:	81 e0       	ldi	r24, 0x01	; 1
     43e:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <drink>
     442:	17 c0       	rjmp	.+46     	; 0x472 <__FUSE_REGION_LENGTH__+0x72>
				else if (drink_select == 0x04) { drink = 2;}
     444:	84 30       	cpi	r24, 0x04	; 4
     446:	21 f4       	brne	.+8      	; 0x450 <__FUSE_REGION_LENGTH__+0x50>
     448:	82 e0       	ldi	r24, 0x02	; 2
     44a:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <drink>
     44e:	11 c0       	rjmp	.+34     	; 0x472 <__FUSE_REGION_LENGTH__+0x72>
				else if (drink_select == 0x08) { drink = 3;}
     450:	88 30       	cpi	r24, 0x08	; 8
     452:	21 f4       	brne	.+8      	; 0x45c <__FUSE_REGION_LENGTH__+0x5c>
     454:	83 e0       	ldi	r24, 0x03	; 3
     456:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <drink>
     45a:	0b c0       	rjmp	.+22     	; 0x472 <__FUSE_REGION_LENGTH__+0x72>
				else if (drink_select == 0x10) { drink = 4;}
     45c:	80 31       	cpi	r24, 0x10	; 16
     45e:	21 f4       	brne	.+8      	; 0x468 <__FUSE_REGION_LENGTH__+0x68>
     460:	84 e0       	ldi	r24, 0x04	; 4
     462:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <drink>
     466:	05 c0       	rjmp	.+10     	; 0x472 <__FUSE_REGION_LENGTH__+0x72>
				else if (drink_select == 0x20) { drink = 5;}
     468:	80 32       	cpi	r24, 0x20	; 32
     46a:	19 f4       	brne	.+6      	; 0x472 <__FUSE_REGION_LENGTH__+0x72>
     46c:	85 e0       	ldi	r24, 0x05	; 5
     46e:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <drink>
				//PORTC = drink;
				steps_next_drink = abs(next_drink * (drink - current_position));
     472:	40 91 28 01 	lds	r20, 0x0128	; 0x800128 <next_drink>
     476:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <drink>
     47a:	90 e0       	ldi	r25, 0x00	; 0
     47c:	20 91 92 07 	lds	r18, 0x0792	; 0x800792 <current_position>
     480:	82 1b       	sub	r24, r18
     482:	91 09       	sbc	r25, r1
     484:	48 9f       	mul	r20, r24
     486:	90 01       	movw	r18, r0
     488:	49 9f       	mul	r20, r25
     48a:	30 0d       	add	r19, r0
     48c:	11 24       	eor	r1, r1
     48e:	33 23       	and	r19, r19
     490:	1c f4       	brge	.+6      	; 0x498 <__FUSE_REGION_LENGTH__+0x98>
     492:	31 95       	neg	r19
     494:	21 95       	neg	r18
     496:	31 09       	sbc	r19, r1
     498:	30 93 91 07 	sts	0x0791, r19	; 0x800791 <steps_next_drink+0x1>
     49c:	20 93 90 07 	sts	0x0790, r18	; 0x800790 <steps_next_drink>
				rotate_state = go_to_drink;
     4a0:	82 e0       	ldi	r24, 0x02	; 2
     4a2:	80 93 f1 07 	sts	0x07F1, r24	; 0x8007f1 <rotate_state>
     4a6:	08 95       	ret
			}
			else if (rotate_flag == 0x01) {
     4a8:	80 91 82 07 	lds	r24, 0x0782	; 0x800782 <rotate_flag>
     4ac:	81 30       	cpi	r24, 0x01	; 1
     4ae:	e9 f4       	brne	.+58     	; 0x4ea <__FUSE_REGION_LENGTH__+0xea>
					//drink = USART_Receive(0) - 1;	
					steps_next_drink = abs(next_drink * (drink - current_position));
     4b0:	40 91 8f 07 	lds	r20, 0x078F	; 0x80078f <drink>
     4b4:	50 91 28 01 	lds	r21, 0x0128	; 0x800128 <next_drink>
     4b8:	84 2f       	mov	r24, r20
     4ba:	90 e0       	ldi	r25, 0x00	; 0
     4bc:	20 91 92 07 	lds	r18, 0x0792	; 0x800792 <current_position>
     4c0:	82 1b       	sub	r24, r18
     4c2:	91 09       	sbc	r25, r1
     4c4:	58 9f       	mul	r21, r24
     4c6:	90 01       	movw	r18, r0
     4c8:	59 9f       	mul	r21, r25
     4ca:	30 0d       	add	r19, r0
     4cc:	11 24       	eor	r1, r1
     4ce:	33 23       	and	r19, r19
     4d0:	1c f4       	brge	.+6      	; 0x4d8 <__FUSE_REGION_LENGTH__+0xd8>
     4d2:	31 95       	neg	r19
     4d4:	21 95       	neg	r18
     4d6:	31 09       	sbc	r19, r1
     4d8:	30 93 91 07 	sts	0x0791, r19	; 0x800791 <steps_next_drink+0x1>
     4dc:	20 93 90 07 	sts	0x0790, r18	; 0x800790 <steps_next_drink>
					rotate_state = go_to_drink;
     4e0:	82 e0       	ldi	r24, 0x02	; 2
     4e2:	80 93 f1 07 	sts	0x07F1, r24	; 0x8007f1 <rotate_state>
					PORTC = drink;
     4e6:	48 b9       	out	0x08, r20	; 8
     4e8:	08 95       	ret
			}
			else {
				rotate_state = Rotate_Wait;
     4ea:	81 e0       	ldi	r24, 0x01	; 1
     4ec:	80 93 f1 07 	sts	0x07F1, r24	; 0x8007f1 <rotate_state>
     4f0:	08 95       	ret
			}
			break;
		case go_to_drink:
			if (total_cnt < steps_next_drink) {
     4f2:	20 91 93 07 	lds	r18, 0x0793	; 0x800793 <total_cnt>
     4f6:	30 91 94 07 	lds	r19, 0x0794	; 0x800794 <total_cnt+0x1>
     4fa:	80 91 90 07 	lds	r24, 0x0790	; 0x800790 <steps_next_drink>
     4fe:	90 91 91 07 	lds	r25, 0x0791	; 0x800791 <steps_next_drink+0x1>
     502:	28 17       	cp	r18, r24
     504:	39 07       	cpc	r19, r25
     506:	20 f4       	brcc	.+8      	; 0x510 <__FUSE_REGION_LENGTH__+0x110>
				rotate_state = go_to_drink;
     508:	82 e0       	ldi	r24, 0x02	; 2
     50a:	80 93 f1 07 	sts	0x07F1, r24	; 0x8007f1 <rotate_state>
     50e:	08 95       	ret
			}
			else {
				current_position = drink;
     510:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <drink>
     514:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <current_position>
				rotate_flag = 0x00;
     518:	10 92 82 07 	sts	0x0782, r1	; 0x800782 <rotate_flag>
				rotate_state = Rotate_Wait;
     51c:	81 e0       	ldi	r24, 0x01	; 1
     51e:	80 93 f1 07 	sts	0x07F1, r24	; 0x8007f1 <rotate_state>
     522:	08 95       	ret
			}
			break;
		
		default:
			rotate_state = Rotate_INIT;
     524:	10 92 f1 07 	sts	0x07F1, r1	; 0x8007f1 <rotate_state>
     528:	08 95       	ret

0000052a <RotateSecTask>:
		USART_Send(0xFF,usartNum);
	}
}

void Rotate_Init(){
	rotate_state = Rotate_INIT;
     52a:	10 92 f1 07 	sts	0x07F1, r1	; 0x8007f1 <rotate_state>
}

void RotateSecTask() {
	Rotate_Init();
	for(;;) { 	
		Rotate_Tick();
     52e:	1a df       	rcall	.-460    	; 0x364 <Rotate_Tick>
		vTaskDelay(6); 
     530:	86 e0       	ldi	r24, 0x06	; 6
     532:	90 e0       	ldi	r25, 0x00	; 0
     534:	0f d6       	rcall	.+3102   	; 0x1154 <vTaskDelay>
	} 
     536:	fb cf       	rjmp	.-10     	; 0x52e <RotateSecTask+0x4>

00000538 <Dispense_Tick>:
			break;
	}
}

void Dispense_Tick(){
	switch(dispense_state){ //actions
     538:	80 91 f2 07 	lds	r24, 0x07F2	; 0x8007f2 <dispense_state>
     53c:	82 30       	cpi	r24, 0x02	; 2
     53e:	a1 f0       	breq	.+40     	; 0x568 <Dispense_Tick+0x30>
     540:	18 f4       	brcc	.+6      	; 0x548 <Dispense_Tick+0x10>
     542:	81 30       	cpi	r24, 0x01	; 1
     544:	31 f0       	breq	.+12     	; 0x552 <Dispense_Tick+0x1a>
     546:	4c c0       	rjmp	.+152    	; 0x5e0 <Dispense_Tick+0xa8>
     548:	83 30       	cpi	r24, 0x03	; 3
     54a:	39 f1       	breq	.+78     	; 0x59a <Dispense_Tick+0x62>
     54c:	84 30       	cpi	r24, 0x04	; 4
     54e:	79 f1       	breq	.+94     	; 0x5ae <Dispense_Tick+0x76>
     550:	47 c0       	rjmp	.+142    	; 0x5e0 <Dispense_Tick+0xa8>
		case Dispense_INIT:
			break;
		case Dispense_Wait:
			dispense_cnt = 0;
     552:	10 92 8b 07 	sts	0x078B, r1	; 0x80078b <dispense_cnt+0x1>
     556:	10 92 8a 07 	sts	0x078A, r1	; 0x80078a <dispense_cnt>
			dispense_index = 0;
     55a:	10 92 89 07 	sts	0x0789, r1	; 0x800789 <dispense_index>
			dispense_hold_cnt = 0;
     55e:	10 92 88 07 	sts	0x0788, r1	; 0x800788 <dispense_hold_cnt+0x1>
     562:	10 92 87 07 	sts	0x0787, r1	; 0x800787 <dispense_hold_cnt>
     566:	4f c0       	rjmp	.+158    	; 0x606 <Dispense_Tick+0xce>
			break;
		case Dispense_Up:
			linear_stepper = backward_steps[dispense_index++];
     568:	80 91 89 07 	lds	r24, 0x0789	; 0x800789 <dispense_index>
     56c:	e8 2f       	mov	r30, r24
     56e:	f0 e0       	ldi	r31, 0x00	; 0
     570:	e6 5d       	subi	r30, 0xD6	; 214
     572:	fe 4f       	sbci	r31, 0xFE	; 254
     574:	90 81       	ld	r25, Z
     576:	90 93 8c 07 	sts	0x078C, r25	; 0x80078c <linear_stepper>
     57a:	8f 5f       	subi	r24, 0xFF	; 255
			dispense_index %= num_steps; 
     57c:	60 91 29 01 	lds	r22, 0x0129	; 0x800129 <num_steps>
     580:	a8 d6       	rcall	.+3408   	; 0x12d2 <__udivmodqi4>
     582:	90 93 89 07 	sts	0x0789, r25	; 0x800789 <dispense_index>
			dispense_cnt++;
     586:	80 91 8a 07 	lds	r24, 0x078A	; 0x80078a <dispense_cnt>
     58a:	90 91 8b 07 	lds	r25, 0x078B	; 0x80078b <dispense_cnt+0x1>
     58e:	01 96       	adiw	r24, 0x01	; 1
     590:	90 93 8b 07 	sts	0x078B, r25	; 0x80078b <dispense_cnt+0x1>
     594:	80 93 8a 07 	sts	0x078A, r24	; 0x80078a <dispense_cnt>
     598:	50 c0       	rjmp	.+160    	; 0x63a <Dispense_Tick+0x102>
			break;
		case Dispense_Hold:
			dispense_hold_cnt++;
     59a:	80 91 87 07 	lds	r24, 0x0787	; 0x800787 <dispense_hold_cnt>
     59e:	90 91 88 07 	lds	r25, 0x0788	; 0x800788 <dispense_hold_cnt+0x1>
     5a2:	01 96       	adiw	r24, 0x01	; 1
     5a4:	90 93 88 07 	sts	0x0788, r25	; 0x800788 <dispense_hold_cnt+0x1>
     5a8:	80 93 87 07 	sts	0x0787, r24	; 0x800787 <dispense_hold_cnt>
     5ac:	5d c0       	rjmp	.+186    	; 0x668 <Dispense_Tick+0x130>
			break;
		case Dispense_Down:
			linear_stepper = forward_steps[dispense_index++];
     5ae:	80 91 89 07 	lds	r24, 0x0789	; 0x800789 <dispense_index>
     5b2:	e8 2f       	mov	r30, r24
     5b4:	f0 e0       	ldi	r31, 0x00	; 0
     5b6:	e2 5d       	subi	r30, 0xD2	; 210
     5b8:	fe 4f       	sbci	r31, 0xFE	; 254
     5ba:	90 81       	ld	r25, Z
     5bc:	90 93 8c 07 	sts	0x078C, r25	; 0x80078c <linear_stepper>
     5c0:	8f 5f       	subi	r24, 0xFF	; 255
			dispense_index %= num_steps;
     5c2:	60 91 29 01 	lds	r22, 0x0129	; 0x800129 <num_steps>
     5c6:	85 d6       	rcall	.+3338   	; 0x12d2 <__udivmodqi4>
     5c8:	90 93 89 07 	sts	0x0789, r25	; 0x800789 <dispense_index>
			dispense_cnt++;
     5cc:	80 91 8a 07 	lds	r24, 0x078A	; 0x80078a <dispense_cnt>
     5d0:	90 91 8b 07 	lds	r25, 0x078B	; 0x80078b <dispense_cnt+0x1>
     5d4:	01 96       	adiw	r24, 0x01	; 1
     5d6:	90 93 8b 07 	sts	0x078B, r25	; 0x80078b <dispense_cnt+0x1>
     5da:	80 93 8a 07 	sts	0x078A, r24	; 0x80078a <dispense_cnt>
     5de:	5f c0       	rjmp	.+190    	; 0x69e <Dispense_Tick+0x166>
			break;
		default:
			break;
	}
	switch(dispense_state){ //transition
     5e0:	82 30       	cpi	r24, 0x02	; 2
     5e2:	59 f1       	breq	.+86     	; 0x63a <Dispense_Tick+0x102>
     5e4:	30 f4       	brcc	.+12     	; 0x5f2 <Dispense_Tick+0xba>
     5e6:	88 23       	and	r24, r24
     5e8:	51 f0       	breq	.+20     	; 0x5fe <Dispense_Tick+0xc6>
     5ea:	81 30       	cpi	r24, 0x01	; 1
     5ec:	09 f0       	breq	.+2      	; 0x5f0 <Dispense_Tick+0xb8>
     5ee:	74 c0       	rjmp	.+232    	; 0x6d8 <Dispense_Tick+0x1a0>
     5f0:	0a c0       	rjmp	.+20     	; 0x606 <Dispense_Tick+0xce>
     5f2:	83 30       	cpi	r24, 0x03	; 3
     5f4:	c9 f1       	breq	.+114    	; 0x668 <Dispense_Tick+0x130>
     5f6:	84 30       	cpi	r24, 0x04	; 4
     5f8:	09 f0       	breq	.+2      	; 0x5fc <Dispense_Tick+0xc4>
     5fa:	6e c0       	rjmp	.+220    	; 0x6d8 <Dispense_Tick+0x1a0>
     5fc:	50 c0       	rjmp	.+160    	; 0x69e <Dispense_Tick+0x166>
		case Dispense_INIT:
			dispense_state = Dispense_Wait;
     5fe:	81 e0       	ldi	r24, 0x01	; 1
     600:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <dispense_state>
			break;
     604:	08 95       	ret
		case Dispense_Wait:
			if ((~PINB & 0x40)==0x40) { // if PINB6 is set to low, dispense
     606:	1e 99       	sbic	0x03, 6	; 3
     608:	08 c0       	rjmp	.+16     	; 0x61a <Dispense_Tick+0xe2>
				//PORTC = 0xFF;
				dispense_state = Dispense_Up;	
     60a:	82 e0       	ldi	r24, 0x02	; 2
     60c:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <dispense_state>
				dispense_cnt = 0;
     610:	10 92 8b 07 	sts	0x078B, r1	; 0x80078b <dispense_cnt+0x1>
     614:	10 92 8a 07 	sts	0x078A, r1	; 0x80078a <dispense_cnt>
     618:	08 95       	ret
			}
			else if (dispense_flag == 0x01) {
     61a:	80 91 83 07 	lds	r24, 0x0783	; 0x800783 <dispense_flag>
     61e:	81 30       	cpi	r24, 0x01	; 1
     620:	41 f4       	brne	.+16     	; 0x632 <Dispense_Tick+0xfa>
				dispense_state = Dispense_Up;
     622:	82 e0       	ldi	r24, 0x02	; 2
     624:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <dispense_state>
				dispense_cnt = 0;
     628:	10 92 8b 07 	sts	0x078B, r1	; 0x80078b <dispense_cnt+0x1>
     62c:	10 92 8a 07 	sts	0x078A, r1	; 0x80078a <dispense_cnt>
     630:	08 95       	ret
			}
			else {
				dispense_state = Dispense_Wait;
     632:	81 e0       	ldi	r24, 0x01	; 1
     634:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <dispense_state>
     638:	08 95       	ret
			}
			break;
		case Dispense_Up:
			if (dispense_cnt >= dispense_totalcnt) {
     63a:	20 91 8a 07 	lds	r18, 0x078A	; 0x80078a <dispense_cnt>
     63e:	30 91 8b 07 	lds	r19, 0x078B	; 0x80078b <dispense_cnt+0x1>
     642:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <dispense_totalcnt>
     646:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <dispense_totalcnt+0x1>
     64a:	28 17       	cp	r18, r24
     64c:	39 07       	cpc	r19, r25
     64e:	40 f0       	brcs	.+16     	; 0x660 <Dispense_Tick+0x128>
				dispense_state = Dispense_Hold;
     650:	83 e0       	ldi	r24, 0x03	; 3
     652:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <dispense_state>
				dispense_cnt = 0;
     656:	10 92 8b 07 	sts	0x078B, r1	; 0x80078b <dispense_cnt+0x1>
     65a:	10 92 8a 07 	sts	0x078A, r1	; 0x80078a <dispense_cnt>
     65e:	08 95       	ret
			}
			else {
				dispense_state = Dispense_Up;
     660:	82 e0       	ldi	r24, 0x02	; 2
     662:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <dispense_state>
     666:	08 95       	ret
			}
			break;
		case Dispense_Hold:
			if (dispense_hold_cnt >= dispense_hold) {
     668:	20 91 87 07 	lds	r18, 0x0787	; 0x800787 <dispense_hold_cnt>
     66c:	30 91 88 07 	lds	r19, 0x0788	; 0x800788 <dispense_hold_cnt+0x1>
     670:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <dispense_hold>
     674:	90 91 25 01 	lds	r25, 0x0125	; 0x800125 <dispense_hold+0x1>
     678:	28 17       	cp	r18, r24
     67a:	39 07       	cpc	r19, r25
     67c:	60 f0       	brcs	.+24     	; 0x696 <Dispense_Tick+0x15e>
				dispense_state = Dispense_Down;
     67e:	84 e0       	ldi	r24, 0x04	; 4
     680:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <dispense_state>
				dispense_hold_cnt = 0;
     684:	10 92 88 07 	sts	0x0788, r1	; 0x800788 <dispense_hold_cnt+0x1>
     688:	10 92 87 07 	sts	0x0787, r1	; 0x800787 <dispense_hold_cnt>
				dispense_cnt = 0;
     68c:	10 92 8b 07 	sts	0x078B, r1	; 0x80078b <dispense_cnt+0x1>
     690:	10 92 8a 07 	sts	0x078A, r1	; 0x80078a <dispense_cnt>
     694:	08 95       	ret
			}
			else {
				dispense_state = Dispense_Hold;
     696:	83 e0       	ldi	r24, 0x03	; 3
     698:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <dispense_state>
     69c:	08 95       	ret
			}
			break;
		case Dispense_Down:
			if (dispense_cnt >= dispense_totalcnt) {
     69e:	20 91 8a 07 	lds	r18, 0x078A	; 0x80078a <dispense_cnt>
     6a2:	30 91 8b 07 	lds	r19, 0x078B	; 0x80078b <dispense_cnt+0x1>
     6a6:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <dispense_totalcnt>
     6aa:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <dispense_totalcnt+0x1>
     6ae:	28 17       	cp	r18, r24
     6b0:	39 07       	cpc	r19, r25
     6b2:	70 f0       	brcs	.+28     	; 0x6d0 <Dispense_Tick+0x198>
				dispense_state = Dispense_Wait;
     6b4:	81 e0       	ldi	r24, 0x01	; 1
     6b6:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <dispense_state>
				dispense_hold_cnt = 0;
     6ba:	10 92 88 07 	sts	0x0788, r1	; 0x800788 <dispense_hold_cnt+0x1>
     6be:	10 92 87 07 	sts	0x0787, r1	; 0x800787 <dispense_hold_cnt>
				dispense_cnt = 0;
     6c2:	10 92 8b 07 	sts	0x078B, r1	; 0x80078b <dispense_cnt+0x1>
     6c6:	10 92 8a 07 	sts	0x078A, r1	; 0x80078a <dispense_cnt>
				dispense_flag = 0;
     6ca:	10 92 83 07 	sts	0x0783, r1	; 0x800783 <dispense_flag>
     6ce:	08 95       	ret
			}
			else {
				dispense_state = Dispense_Down;
     6d0:	84 e0       	ldi	r24, 0x04	; 4
     6d2:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <dispense_state>
     6d6:	08 95       	ret
			}
			break;
		default:
			dispense_state = Dispense_Wait;
     6d8:	81 e0       	ldi	r24, 0x01	; 1
     6da:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <dispense_state>
     6de:	08 95       	ret

000006e0 <DispenseSecTask>:
void Rotate_Init(){
	rotate_state = Rotate_INIT;
}

void Dispense_Init(){
	dispense_state = Dispense_INIT;
     6e0:	10 92 f2 07 	sts	0x07F2, r1	; 0x8007f2 <dispense_state>
}

void DispenseSecTask() {
	Dispense_Init();
	for(;;) { 	
		Dispense_Tick();
     6e4:	29 df       	rcall	.-430    	; 0x538 <Dispense_Tick>
		vTaskDelay(8); 
     6e6:	88 e0       	ldi	r24, 0x08	; 8
     6e8:	90 e0       	ldi	r25, 0x00	; 0
     6ea:	34 d5       	rcall	.+2664   	; 0x1154 <vTaskDelay>
	} 
     6ec:	fb cf       	rjmp	.-10     	; 0x6e4 <DispenseSecTask+0x4>

000006ee <WritePORTA_Tick>:
		case WritePORTA_Wait:
			break;
		default:
			break;
	}
	switch (write_porta_state){ //transitions
     6ee:	80 91 f4 07 	lds	r24, 0x07F4	; 0x8007f4 <write_porta_state>
     6f2:	88 23       	and	r24, r24
     6f4:	19 f0       	breq	.+6      	; 0x6fc <WritePORTA_Tick+0xe>
     6f6:	81 30       	cpi	r24, 0x01	; 1
     6f8:	31 f0       	breq	.+12     	; 0x706 <WritePORTA_Tick+0x18>
     6fa:	13 c0       	rjmp	.+38     	; 0x722 <WritePORTA_Tick+0x34>
		case WritePORTA_INIT:
			PORTA = 0;
     6fc:	12 b8       	out	0x02, r1	; 2
			write_porta_state = WritePORTA_Wait;
     6fe:	81 e0       	ldi	r24, 0x01	; 1
     700:	80 93 f4 07 	sts	0x07F4, r24	; 0x8007f4 <write_porta_state>
			break;
     704:	08 95       	ret
		case WritePORTA_Wait:
			PORTA = rotate_stepper | (linear_stepper << 4);
     706:	80 91 8c 07 	lds	r24, 0x078C	; 0x80078c <linear_stepper>
     70a:	20 e1       	ldi	r18, 0x10	; 16
     70c:	82 9f       	mul	r24, r18
     70e:	c0 01       	movw	r24, r0
     710:	11 24       	eor	r1, r1
     712:	90 91 8d 07 	lds	r25, 0x078D	; 0x80078d <rotate_stepper>
     716:	89 2b       	or	r24, r25
     718:	82 b9       	out	0x02, r24	; 2
			write_porta_state = WritePORTA_Wait;
     71a:	81 e0       	ldi	r24, 0x01	; 1
     71c:	80 93 f4 07 	sts	0x07F4, r24	; 0x8007f4 <write_porta_state>
			break;
     720:	08 95       	ret
		default:
			write_porta_state = WritePORTA_Wait;
     722:	81 e0       	ldi	r24, 0x01	; 1
     724:	80 93 f4 07 	sts	0x07F4, r24	; 0x8007f4 <write_porta_state>
			PORTA = 0;
     728:	12 b8       	out	0x02, r1	; 2
     72a:	08 95       	ret

0000072c <WritePORTASecTask>:
void Dispense_Init(){
	dispense_state = Dispense_INIT;
}

void WritePORTA_Init() {
	write_porta_state = WritePORTA_INIT;
     72c:	10 92 f4 07 	sts	0x07F4, r1	; 0x8007f4 <write_porta_state>
}

void WritePORTASecTask() {
	WritePORTA_Init();
	for(;;) { 	
		WritePORTA_Tick();
     730:	de df       	rcall	.-68     	; 0x6ee <WritePORTA_Tick>
		vTaskDelay(1); 
     732:	81 e0       	ldi	r24, 0x01	; 1
     734:	90 e0       	ldi	r25, 0x00	; 0
     736:	0e d5       	rcall	.+2588   	; 0x1154 <vTaskDelay>
	}
     738:	fb cf       	rjmp	.-10     	; 0x730 <WritePORTASecTask+0x4>

0000073a <PollUSART_Tick>:
			break;	
	}
}

void PollUSART_Tick() {
	switch (poll_usart_state) { //actions
     73a:	80 91 f0 07 	lds	r24, 0x07F0	; 0x8007f0 <poll_usart_state>
     73e:	81 30       	cpi	r24, 0x01	; 1
     740:	b1 f4       	brne	.+44     	; 0x76e <PollUSART_Tick+0x34>
//Functionality - checks if USART has recieved data
//Parameter: usartNum specifies which USART is checked
//Returns: 1 if true else 0
unsigned char USART_HasReceived(unsigned char usartNum)
{
	return (usartNum != 1) ? (UCSR0A & (1 << RXC0)) : (UCSR1A & (1 << RXC1));
     742:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
		case PollUSART_INIT:
			break;
		case PollUSART_Wait:
			if (USART_HasReceived(0)) {
     746:	88 23       	and	r24, r24
     748:	14 f5       	brge	.+68     	; 0x78e <PollUSART_Tick+0x54>
				received_message = USART_Receive(0);	
     74a:	80 e0       	ldi	r24, 0x00	; 0
     74c:	d2 dd       	rcall	.-1116   	; 0x2f2 <USART_Receive>
     74e:	80 93 86 07 	sts	0x0786, r24	; 0x800786 <received_message>
				if (received_message == 0xAA) {
     752:	8a 3a       	cpi	r24, 0xAA	; 170
     754:	51 f4       	brne	.+20     	; 0x76a <PollUSART_Tick+0x30>
					make_drink_flag = 0x01;
     756:	81 e0       	ldi	r24, 0x01	; 1
     758:	80 93 85 07 	sts	0x0785, r24	; 0x800785 <make_drink_flag>
					drink_to_make = USART_Receive(0);
     75c:	80 e0       	ldi	r24, 0x00	; 0
     75e:	c9 dd       	rcall	.-1134   	; 0x2f2 <USART_Receive>
     760:	80 93 84 07 	sts	0x0784, r24	; 0x800784 <drink_to_make>
					USART_Flush(0);
     764:	80 e0       	ldi	r24, 0x00	; 0
     766:	92 dd       	rcall	.-1244   	; 0x28c <USART_Flush>
     768:	02 c0       	rjmp	.+4      	; 0x76e <PollUSART_Tick+0x34>
				}
				else {
					make_drink_flag = 0x00;
     76a:	10 92 85 07 	sts	0x0785, r1	; 0x800785 <make_drink_flag>
			}
			break;
		default:
			break;
	}
	switch (poll_usart_state) { //transitions
     76e:	80 91 f0 07 	lds	r24, 0x07F0	; 0x8007f0 <poll_usart_state>
     772:	88 23       	and	r24, r24
     774:	19 f0       	breq	.+6      	; 0x77c <PollUSART_Tick+0x42>
     776:	81 30       	cpi	r24, 0x01	; 1
     778:	39 f4       	brne	.+14     	; 0x788 <PollUSART_Tick+0x4e>
     77a:	08 95       	ret
		case PollUSART_INIT:
			poll_usart_state = PollUSART_Wait;
     77c:	81 e0       	ldi	r24, 0x01	; 1
     77e:	80 93 f0 07 	sts	0x07F0, r24	; 0x8007f0 <poll_usart_state>
			received_message = 0;
     782:	10 92 86 07 	sts	0x0786, r1	; 0x800786 <received_message>
			break;
     786:	08 95       	ret
		case PollUSART_Wait:
			poll_usart_state = PollUSART_Wait;
			break;
		default:
			poll_usart_state = PollUSART_Wait;
     788:	81 e0       	ldi	r24, 0x01	; 1
     78a:	80 93 f0 07 	sts	0x07F0, r24	; 0x8007f0 <poll_usart_state>
     78e:	08 95       	ret

00000790 <PollUSARTSecTask>:
void WritePORTA_Init() {
	write_porta_state = WritePORTA_INIT;
}

void PollUSART_Init() {
	poll_usart_state = PollUSART_INIT;
     790:	10 92 f0 07 	sts	0x07F0, r1	; 0x8007f0 <poll_usart_state>
}

void PollUSARTSecTask() {
	PollUSART_Init();
	for(;;) { 	
		PollUSART_Tick();
     794:	d2 df       	rcall	.-92     	; 0x73a <PollUSART_Tick>
		vTaskDelay(1); 
     796:	81 e0       	ldi	r24, 0x01	; 1
     798:	90 e0       	ldi	r25, 0x00	; 0
     79a:	dc d4       	rcall	.+2488   	; 0x1154 <vTaskDelay>
	}
     79c:	fb cf       	rjmp	.-10     	; 0x794 <PollUSARTSecTask+0x4>

0000079e <MakeDrink_Tick>:
			poll_usart_state = PollUSART_Wait;
			break;
	}
}

void MakeDrink_Tick() {
     79e:	cf 93       	push	r28
	switch (make_drink_state) { //actions
     7a0:	80 91 f5 07 	lds	r24, 0x07F5	; 0x8007f5 <make_drink_state>
     7a4:	81 30       	cpi	r24, 0x01	; 1
     7a6:	19 f4       	brne	.+6      	; 0x7ae <MakeDrink_Tick+0x10>
		case MakeDrink_INIT:
			break;
		case MakeDrink_Wait:
			make_drink_cnt = 0;
     7a8:	10 92 81 07 	sts	0x0781, r1	; 0x800781 <make_drink_cnt>
     7ac:	1a c0       	rjmp	.+52     	; 0x7e2 <MakeDrink_Tick+0x44>
		case MakeDrink_Dispense:
			break;
		default:
			break;
	}
	switch (make_drink_state) { //transitions
     7ae:	82 30       	cpi	r24, 0x02	; 2
     7b0:	81 f1       	breq	.+96     	; 0x812 <MakeDrink_Tick+0x74>
     7b2:	30 f4       	brcc	.+12     	; 0x7c0 <MakeDrink_Tick+0x22>
     7b4:	88 23       	and	r24, r24
     7b6:	59 f0       	breq	.+22     	; 0x7ce <MakeDrink_Tick+0x30>
     7b8:	81 30       	cpi	r24, 0x01	; 1
     7ba:	09 f0       	breq	.+2      	; 0x7be <MakeDrink_Tick+0x20>
     7bc:	77 c0       	rjmp	.+238    	; 0x8ac <MakeDrink_Tick+0x10e>
     7be:	11 c0       	rjmp	.+34     	; 0x7e2 <MakeDrink_Tick+0x44>
     7c0:	83 30       	cpi	r24, 0x03	; 3
     7c2:	09 f4       	brne	.+2      	; 0x7c6 <MakeDrink_Tick+0x28>
     7c4:	5b c0       	rjmp	.+182    	; 0x87c <MakeDrink_Tick+0xde>
     7c6:	84 30       	cpi	r24, 0x04	; 4
     7c8:	09 f4       	brne	.+2      	; 0x7cc <MakeDrink_Tick+0x2e>
     7ca:	63 c0       	rjmp	.+198    	; 0x892 <MakeDrink_Tick+0xf4>
     7cc:	6f c0       	rjmp	.+222    	; 0x8ac <MakeDrink_Tick+0x10e>
		case MakeDrink_INIT:
			make_drink_state = MakeDrink_Wait;
     7ce:	81 e0       	ldi	r24, 0x01	; 1
     7d0:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <make_drink_state>
			make_drink_cnt = 0;
     7d4:	10 92 81 07 	sts	0x0781, r1	; 0x800781 <make_drink_cnt>
			rotate_flag = 0;
     7d8:	10 92 82 07 	sts	0x0782, r1	; 0x800782 <rotate_flag>
			dispense_flag = 0;
     7dc:	10 92 83 07 	sts	0x0783, r1	; 0x800783 <dispense_flag>
			break;
     7e0:	68 c0       	rjmp	.+208    	; 0x8b2 <MakeDrink_Tick+0x114>
		case MakeDrink_Wait:
			if (make_drink_flag == 0x01 && rotate_flag == 0 && dispense_flag == 0) {
     7e2:	80 91 85 07 	lds	r24, 0x0785	; 0x800785 <make_drink_flag>
     7e6:	81 30       	cpi	r24, 0x01	; 1
     7e8:	81 f4       	brne	.+32     	; 0x80a <MakeDrink_Tick+0x6c>
     7ea:	80 91 82 07 	lds	r24, 0x0782	; 0x800782 <rotate_flag>
     7ee:	81 11       	cpse	r24, r1
     7f0:	0c c0       	rjmp	.+24     	; 0x80a <MakeDrink_Tick+0x6c>
     7f2:	80 91 83 07 	lds	r24, 0x0783	; 0x800783 <dispense_flag>
     7f6:	81 11       	cpse	r24, r1
     7f8:	08 c0       	rjmp	.+16     	; 0x80a <MakeDrink_Tick+0x6c>
				USART_Send_String("page page2",0);
     7fa:	60 e0       	ldi	r22, 0x00	; 0
     7fc:	84 e3       	ldi	r24, 0x34	; 52
     7fe:	91 e0       	ldi	r25, 0x01	; 1
     800:	8a dd       	rcall	.-1260   	; 0x316 <USART_Send_String>
				make_drink_state = MakeDrink;
     802:	82 e0       	ldi	r24, 0x02	; 2
     804:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <make_drink_state>
     808:	54 c0       	rjmp	.+168    	; 0x8b2 <MakeDrink_Tick+0x114>
			}
			else {
				make_drink_state = MakeDrink_Wait;
     80a:	81 e0       	ldi	r24, 0x01	; 1
     80c:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <make_drink_state>
     810:	50 c0       	rjmp	.+160    	; 0x8b2 <MakeDrink_Tick+0x114>
			}
			break;
		case MakeDrink:
			if (drinks[drink_to_make][make_drink_cnt]==0x01 && make_drink_cnt < 6) {
     812:	20 91 81 07 	lds	r18, 0x0781	; 0x800781 <make_drink_cnt>
     816:	80 91 84 07 	lds	r24, 0x0784	; 0x800784 <drink_to_make>
     81a:	90 e0       	ldi	r25, 0x00	; 0
     81c:	fc 01       	movw	r30, r24
     81e:	ee 0f       	add	r30, r30
     820:	ff 1f       	adc	r31, r31
     822:	e8 0f       	add	r30, r24
     824:	f9 1f       	adc	r31, r25
     826:	ee 0f       	add	r30, r30
     828:	ff 1f       	adc	r31, r31
     82a:	e2 0f       	add	r30, r18
     82c:	f1 1d       	adc	r31, r1
     82e:	e0 50       	subi	r30, 0x00	; 0
     830:	ff 4f       	sbci	r31, 0xFF	; 255
     832:	80 81       	ld	r24, Z
     834:	81 30       	cpi	r24, 0x01	; 1
     836:	59 f4       	brne	.+22     	; 0x84e <MakeDrink_Tick+0xb0>
     838:	26 30       	cpi	r18, 0x06	; 6
     83a:	58 f4       	brcc	.+22     	; 0x852 <MakeDrink_Tick+0xb4>
				make_drink_state = MakeDrink_Rotate;
     83c:	83 e0       	ldi	r24, 0x03	; 3
     83e:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <make_drink_state>
				rotate_flag = 0x01;
     842:	81 e0       	ldi	r24, 0x01	; 1
     844:	80 93 82 07 	sts	0x0782, r24	; 0x800782 <rotate_flag>
				drink = make_drink_cnt;
     848:	20 93 8f 07 	sts	0x078F, r18	; 0x80078f <drink>
     84c:	32 c0       	rjmp	.+100    	; 0x8b2 <MakeDrink_Tick+0x114>
			}
			else if (make_drink_cnt >= 6) {
     84e:	26 30       	cpi	r18, 0x06	; 6
     850:	70 f0       	brcs	.+28     	; 0x86e <MakeDrink_Tick+0xd0>
				make_drink_state = MakeDrink_Wait;
     852:	c1 e0       	ldi	r28, 0x01	; 1
     854:	c0 93 f5 07 	sts	0x07F5, r28	; 0x8007f5 <make_drink_state>
				USART_Send_String("page page0",0);
     858:	60 e0       	ldi	r22, 0x00	; 0
     85a:	8f e3       	ldi	r24, 0x3F	; 63
     85c:	91 e0       	ldi	r25, 0x01	; 1
     85e:	5b dd       	rcall	.-1354   	; 0x316 <USART_Send_String>
				make_drink_flag = 0x00;
     860:	10 92 85 07 	sts	0x0785, r1	; 0x800785 <make_drink_flag>
				rotate_flag = 0x01;
     864:	c0 93 82 07 	sts	0x0782, r28	; 0x800782 <rotate_flag>
				drink = 0;
     868:	10 92 8f 07 	sts	0x078F, r1	; 0x80078f <drink>
     86c:	22 c0       	rjmp	.+68     	; 0x8b2 <MakeDrink_Tick+0x114>
			}
			else {
				make_drink_cnt++;
     86e:	2f 5f       	subi	r18, 0xFF	; 255
     870:	20 93 81 07 	sts	0x0781, r18	; 0x800781 <make_drink_cnt>
				make_drink_state = MakeDrink;
     874:	82 e0       	ldi	r24, 0x02	; 2
     876:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <make_drink_state>
     87a:	1b c0       	rjmp	.+54     	; 0x8b2 <MakeDrink_Tick+0x114>
			}
			break;
		case MakeDrink_Rotate:
			if (rotate_flag == 0x00) {
     87c:	80 91 82 07 	lds	r24, 0x0782	; 0x800782 <rotate_flag>
     880:	81 11       	cpse	r24, r1
     882:	17 c0       	rjmp	.+46     	; 0x8b2 <MakeDrink_Tick+0x114>
				dispense_flag = 0x01;
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	80 93 83 07 	sts	0x0783, r24	; 0x800783 <dispense_flag>
				make_drink_state = MakeDrink_Dispense;
     88a:	84 e0       	ldi	r24, 0x04	; 4
     88c:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <make_drink_state>
     890:	10 c0       	rjmp	.+32     	; 0x8b2 <MakeDrink_Tick+0x114>
			else {
				make_drink_state = MakeDrink_Rotate;
			}
			break;
		case MakeDrink_Dispense:
			if (dispense_flag == 0x00) {// && make_drink_cnt < 6) {
     892:	80 91 83 07 	lds	r24, 0x0783	; 0x800783 <dispense_flag>
     896:	81 11       	cpse	r24, r1
     898:	0c c0       	rjmp	.+24     	; 0x8b2 <MakeDrink_Tick+0x114>
				make_drink_cnt++;
     89a:	80 91 81 07 	lds	r24, 0x0781	; 0x800781 <make_drink_cnt>
     89e:	8f 5f       	subi	r24, 0xFF	; 255
     8a0:	80 93 81 07 	sts	0x0781, r24	; 0x800781 <make_drink_cnt>
				make_drink_state = MakeDrink;
     8a4:	82 e0       	ldi	r24, 0x02	; 2
     8a6:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <make_drink_state>
     8aa:	03 c0       	rjmp	.+6      	; 0x8b2 <MakeDrink_Tick+0x114>
			else {
				make_drink_state = MakeDrink_Dispense;
			}
			break;
		default:
			make_drink_state = MakeDrink_Wait;
     8ac:	81 e0       	ldi	r24, 0x01	; 1
     8ae:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <make_drink_state>
			break;
	}
}
     8b2:	cf 91       	pop	r28
     8b4:	08 95       	ret

000008b6 <MakeDrinkSecTask>:
void PollUSART_Init() {
	poll_usart_state = PollUSART_INIT;
}

void MakeDrink_Init() {
	make_drink_state = MakeDrink_INIT;
     8b6:	10 92 f5 07 	sts	0x07F5, r1	; 0x8007f5 <make_drink_state>
}

void MakeDrinkSecTask() {
	MakeDrink_Init();
	for(;;) { 	
		MakeDrink_Tick();
     8ba:	71 df       	rcall	.-286    	; 0x79e <MakeDrink_Tick>
		vTaskDelay(1); 
     8bc:	81 e0       	ldi	r24, 0x01	; 1
     8be:	90 e0       	ldi	r25, 0x00	; 0
     8c0:	49 d4       	rcall	.+2194   	; 0x1154 <vTaskDelay>
	}
     8c2:	fb cf       	rjmp	.-10     	; 0x8ba <MakeDrinkSecTask+0x4>

000008c4 <StartSecPulse>:
}

void StartSecPulse(unsigned portBASE_TYPE Priority) {
     8c4:	af 92       	push	r10
     8c6:	bf 92       	push	r11
     8c8:	cf 92       	push	r12
     8ca:	df 92       	push	r13
     8cc:	ef 92       	push	r14
     8ce:	ff 92       	push	r15
     8d0:	0f 93       	push	r16
     8d2:	cf 93       	push	r28
	xTaskCreate(RotateSecTask, (signed portCHAR *)"RotateSecTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
     8d4:	a1 2c       	mov	r10, r1
     8d6:	b1 2c       	mov	r11, r1
     8d8:	c1 2c       	mov	r12, r1
     8da:	d1 2c       	mov	r13, r1
     8dc:	e1 2c       	mov	r14, r1
     8de:	f1 2c       	mov	r15, r1
     8e0:	08 2f       	mov	r16, r24
     8e2:	20 e0       	ldi	r18, 0x00	; 0
     8e4:	30 e0       	ldi	r19, 0x00	; 0
     8e6:	45 e5       	ldi	r20, 0x55	; 85
     8e8:	50 e0       	ldi	r21, 0x00	; 0
     8ea:	6a e4       	ldi	r22, 0x4A	; 74
     8ec:	71 e0       	ldi	r23, 0x01	; 1
     8ee:	85 e9       	ldi	r24, 0x95	; 149
     8f0:	92 e0       	ldi	r25, 0x02	; 2
     8f2:	cc d1       	rcall	.+920    	; 0xc8c <xTaskGenericCreate>
	xTaskCreate(DispenseSecTask, (signed portCHAR *)"DispenseSecTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
     8f4:	20 e0       	ldi	r18, 0x00	; 0
     8f6:	30 e0       	ldi	r19, 0x00	; 0
     8f8:	45 e5       	ldi	r20, 0x55	; 85
     8fa:	50 e0       	ldi	r21, 0x00	; 0
     8fc:	68 e5       	ldi	r22, 0x58	; 88
     8fe:	71 e0       	ldi	r23, 0x01	; 1
     900:	80 e7       	ldi	r24, 0x70	; 112
     902:	93 e0       	ldi	r25, 0x03	; 3
     904:	c3 d1       	rcall	.+902    	; 0xc8c <xTaskGenericCreate>
	xTaskCreate(WritePORTASecTask, (signed portCHAR *)"WritePORTASecTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
     906:	20 e0       	ldi	r18, 0x00	; 0
     908:	30 e0       	ldi	r19, 0x00	; 0
     90a:	45 e5       	ldi	r20, 0x55	; 85
     90c:	50 e0       	ldi	r21, 0x00	; 0
     90e:	68 e6       	ldi	r22, 0x68	; 104
     910:	71 e0       	ldi	r23, 0x01	; 1
     912:	86 e9       	ldi	r24, 0x96	; 150
     914:	93 e0       	ldi	r25, 0x03	; 3
     916:	ba d1       	rcall	.+884    	; 0xc8c <xTaskGenericCreate>
	xTaskCreate(PollUSARTSecTask, (signed portCHAR *)"PollUSARTSecTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
     918:	20 e0       	ldi	r18, 0x00	; 0
     91a:	30 e0       	ldi	r19, 0x00	; 0
     91c:	45 e5       	ldi	r20, 0x55	; 85
     91e:	50 e0       	ldi	r21, 0x00	; 0
     920:	6a e7       	ldi	r22, 0x7A	; 122
     922:	71 e0       	ldi	r23, 0x01	; 1
     924:	88 ec       	ldi	r24, 0xC8	; 200
     926:	93 e0       	ldi	r25, 0x03	; 3
     928:	b1 d1       	rcall	.+866    	; 0xc8c <xTaskGenericCreate>
	xTaskCreate(MakeDrinkSecTask, (signed portCHAR *)"MakeDrinkSecTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
     92a:	20 e0       	ldi	r18, 0x00	; 0
     92c:	30 e0       	ldi	r19, 0x00	; 0
     92e:	45 e5       	ldi	r20, 0x55	; 85
     930:	50 e0       	ldi	r21, 0x00	; 0
     932:	6b e8       	ldi	r22, 0x8B	; 139
     934:	71 e0       	ldi	r23, 0x01	; 1
     936:	8b e5       	ldi	r24, 0x5B	; 91
     938:	94 e0       	ldi	r25, 0x04	; 4
     93a:	a8 d1       	rcall	.+848    	; 0xc8c <xTaskGenericCreate>
}
     93c:	cf 91       	pop	r28
     93e:	0f 91       	pop	r16
     940:	ff 90       	pop	r15
     942:	ef 90       	pop	r14
     944:	df 90       	pop	r13
     946:	cf 90       	pop	r12
     948:	bf 90       	pop	r11
     94a:	af 90       	pop	r10
     94c:	08 95       	ret

0000094e <main>:

int main(void) { 
	DDRA = 0xFF; PORTA = 0x00;//Set PORTA as output
     94e:	8f ef       	ldi	r24, 0xFF	; 255
     950:	81 b9       	out	0x01, r24	; 1
     952:	12 b8       	out	0x02, r1	; 2
	DDRB = 0x00; PORTB = 0xFF;//Set PORTB as input
     954:	14 b8       	out	0x04, r1	; 4
     956:	85 b9       	out	0x05, r24	; 5
	DDRC = 0xFF; PORTC = 0x00;//Set PORTA as output
     958:	87 b9       	out	0x07, r24	; 7
     95a:	18 b8       	out	0x08, r1	; 8
	
	initUSART(0);
     95c:	80 e0       	ldi	r24, 0x00	; 0
     95e:	74 dc       	rcall	.-1816   	; 0x248 <initUSART>
	initUSART(1);
     960:	81 e0       	ldi	r24, 0x01	; 1
     962:	72 dc       	rcall	.-1820   	; 0x248 <initUSART>
	//Start Tasks  
	StartSecPulse(1);
     964:	81 e0       	ldi	r24, 0x01	; 1
     966:	ae df       	rcall	.-164    	; 0x8c4 <StartSecPulse>
	//RunSchedular 
	vTaskStartScheduler(); 
     968:	84 d2       	rcall	.+1288   	; 0xe72 <vTaskStartScheduler>
 
	return 0; 
     96a:	80 e0       	ldi	r24, 0x00	; 0
     96c:	90 e0       	ldi	r25, 0x00	; 0
     96e:	08 95       	ret

00000970 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     970:	31 e1       	ldi	r19, 0x11	; 17
     972:	fc 01       	movw	r30, r24
     974:	30 83       	st	Z, r19
     976:	31 97       	sbiw	r30, 0x01	; 1
     978:	22 e2       	ldi	r18, 0x22	; 34
     97a:	20 83       	st	Z, r18
     97c:	31 97       	sbiw	r30, 0x01	; 1
     97e:	a3 e3       	ldi	r26, 0x33	; 51
     980:	a0 83       	st	Z, r26
     982:	31 97       	sbiw	r30, 0x01	; 1
     984:	60 83       	st	Z, r22
     986:	31 97       	sbiw	r30, 0x01	; 1
     988:	70 83       	st	Z, r23
     98a:	31 97       	sbiw	r30, 0x01	; 1
     98c:	10 82       	st	Z, r1
     98e:	31 97       	sbiw	r30, 0x01	; 1
     990:	60 e8       	ldi	r22, 0x80	; 128
     992:	60 83       	st	Z, r22
     994:	31 97       	sbiw	r30, 0x01	; 1
     996:	10 82       	st	Z, r1
     998:	31 97       	sbiw	r30, 0x01	; 1
     99a:	62 e0       	ldi	r22, 0x02	; 2
     99c:	60 83       	st	Z, r22
     99e:	31 97       	sbiw	r30, 0x01	; 1
     9a0:	63 e0       	ldi	r22, 0x03	; 3
     9a2:	60 83       	st	Z, r22
     9a4:	31 97       	sbiw	r30, 0x01	; 1
     9a6:	64 e0       	ldi	r22, 0x04	; 4
     9a8:	60 83       	st	Z, r22
     9aa:	31 97       	sbiw	r30, 0x01	; 1
     9ac:	65 e0       	ldi	r22, 0x05	; 5
     9ae:	60 83       	st	Z, r22
     9b0:	31 97       	sbiw	r30, 0x01	; 1
     9b2:	66 e0       	ldi	r22, 0x06	; 6
     9b4:	60 83       	st	Z, r22
     9b6:	31 97       	sbiw	r30, 0x01	; 1
     9b8:	67 e0       	ldi	r22, 0x07	; 7
     9ba:	60 83       	st	Z, r22
     9bc:	31 97       	sbiw	r30, 0x01	; 1
     9be:	68 e0       	ldi	r22, 0x08	; 8
     9c0:	60 83       	st	Z, r22
     9c2:	31 97       	sbiw	r30, 0x01	; 1
     9c4:	69 e0       	ldi	r22, 0x09	; 9
     9c6:	60 83       	st	Z, r22
     9c8:	31 97       	sbiw	r30, 0x01	; 1
     9ca:	60 e1       	ldi	r22, 0x10	; 16
     9cc:	60 83       	st	Z, r22
     9ce:	31 97       	sbiw	r30, 0x01	; 1
     9d0:	30 83       	st	Z, r19
     9d2:	31 97       	sbiw	r30, 0x01	; 1
     9d4:	32 e1       	ldi	r19, 0x12	; 18
     9d6:	30 83       	st	Z, r19
     9d8:	31 97       	sbiw	r30, 0x01	; 1
     9da:	33 e1       	ldi	r19, 0x13	; 19
     9dc:	30 83       	st	Z, r19
     9de:	31 97       	sbiw	r30, 0x01	; 1
     9e0:	34 e1       	ldi	r19, 0x14	; 20
     9e2:	30 83       	st	Z, r19
     9e4:	31 97       	sbiw	r30, 0x01	; 1
     9e6:	35 e1       	ldi	r19, 0x15	; 21
     9e8:	30 83       	st	Z, r19
     9ea:	31 97       	sbiw	r30, 0x01	; 1
     9ec:	36 e1       	ldi	r19, 0x16	; 22
     9ee:	30 83       	st	Z, r19
     9f0:	31 97       	sbiw	r30, 0x01	; 1
     9f2:	37 e1       	ldi	r19, 0x17	; 23
     9f4:	30 83       	st	Z, r19
     9f6:	31 97       	sbiw	r30, 0x01	; 1
     9f8:	38 e1       	ldi	r19, 0x18	; 24
     9fa:	30 83       	st	Z, r19
     9fc:	31 97       	sbiw	r30, 0x01	; 1
     9fe:	39 e1       	ldi	r19, 0x19	; 25
     a00:	30 83       	st	Z, r19
     a02:	31 97       	sbiw	r30, 0x01	; 1
     a04:	30 e2       	ldi	r19, 0x20	; 32
     a06:	30 83       	st	Z, r19
     a08:	31 97       	sbiw	r30, 0x01	; 1
     a0a:	31 e2       	ldi	r19, 0x21	; 33
     a0c:	30 83       	st	Z, r19
     a0e:	31 97       	sbiw	r30, 0x01	; 1
     a10:	20 83       	st	Z, r18
     a12:	31 97       	sbiw	r30, 0x01	; 1
     a14:	23 e2       	ldi	r18, 0x23	; 35
     a16:	20 83       	st	Z, r18
     a18:	31 97       	sbiw	r30, 0x01	; 1
     a1a:	40 83       	st	Z, r20
     a1c:	31 97       	sbiw	r30, 0x01	; 1
     a1e:	50 83       	st	Z, r21
     a20:	31 97       	sbiw	r30, 0x01	; 1
     a22:	26 e2       	ldi	r18, 0x26	; 38
     a24:	20 83       	st	Z, r18
     a26:	31 97       	sbiw	r30, 0x01	; 1
     a28:	27 e2       	ldi	r18, 0x27	; 39
     a2a:	20 83       	st	Z, r18
     a2c:	31 97       	sbiw	r30, 0x01	; 1
     a2e:	28 e2       	ldi	r18, 0x28	; 40
     a30:	20 83       	st	Z, r18
     a32:	31 97       	sbiw	r30, 0x01	; 1
     a34:	29 e2       	ldi	r18, 0x29	; 41
     a36:	20 83       	st	Z, r18
     a38:	31 97       	sbiw	r30, 0x01	; 1
     a3a:	20 e3       	ldi	r18, 0x30	; 48
     a3c:	20 83       	st	Z, r18
     a3e:	31 97       	sbiw	r30, 0x01	; 1
     a40:	21 e3       	ldi	r18, 0x31	; 49
     a42:	20 83       	st	Z, r18
     a44:	86 97       	sbiw	r24, 0x26	; 38
     a46:	08 95       	ret

00000a48 <xPortStartScheduler>:
     a48:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     a4c:	8c e7       	ldi	r24, 0x7C	; 124
     a4e:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
     a52:	8b e0       	ldi	r24, 0x0B	; 11
     a54:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     a58:	ef e6       	ldi	r30, 0x6F	; 111
     a5a:	f0 e0       	ldi	r31, 0x00	; 0
     a5c:	80 81       	ld	r24, Z
     a5e:	82 60       	ori	r24, 0x02	; 2
     a60:	80 83       	st	Z, r24
     a62:	a0 91 ee 07 	lds	r26, 0x07EE	; 0x8007ee <pxCurrentTCB>
     a66:	b0 91 ef 07 	lds	r27, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
     a6a:	cd 91       	ld	r28, X+
     a6c:	cd bf       	out	0x3d, r28	; 61
     a6e:	dd 91       	ld	r29, X+
     a70:	de bf       	out	0x3e, r29	; 62
     a72:	ff 91       	pop	r31
     a74:	ef 91       	pop	r30
     a76:	df 91       	pop	r29
     a78:	cf 91       	pop	r28
     a7a:	bf 91       	pop	r27
     a7c:	af 91       	pop	r26
     a7e:	9f 91       	pop	r25
     a80:	8f 91       	pop	r24
     a82:	7f 91       	pop	r23
     a84:	6f 91       	pop	r22
     a86:	5f 91       	pop	r21
     a88:	4f 91       	pop	r20
     a8a:	3f 91       	pop	r19
     a8c:	2f 91       	pop	r18
     a8e:	1f 91       	pop	r17
     a90:	0f 91       	pop	r16
     a92:	ff 90       	pop	r15
     a94:	ef 90       	pop	r14
     a96:	df 90       	pop	r13
     a98:	cf 90       	pop	r12
     a9a:	bf 90       	pop	r11
     a9c:	af 90       	pop	r10
     a9e:	9f 90       	pop	r9
     aa0:	8f 90       	pop	r8
     aa2:	7f 90       	pop	r7
     aa4:	6f 90       	pop	r6
     aa6:	5f 90       	pop	r5
     aa8:	4f 90       	pop	r4
     aaa:	3f 90       	pop	r3
     aac:	2f 90       	pop	r2
     aae:	1f 90       	pop	r1
     ab0:	0f 90       	pop	r0
     ab2:	0f be       	out	0x3f, r0	; 63
     ab4:	0f 90       	pop	r0
     ab6:	08 95       	ret
     ab8:	81 e0       	ldi	r24, 0x01	; 1
     aba:	08 95       	ret

00000abc <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     abc:	0f 92       	push	r0
     abe:	0f b6       	in	r0, 0x3f	; 63
     ac0:	f8 94       	cli
     ac2:	0f 92       	push	r0
     ac4:	1f 92       	push	r1
     ac6:	11 24       	eor	r1, r1
     ac8:	2f 92       	push	r2
     aca:	3f 92       	push	r3
     acc:	4f 92       	push	r4
     ace:	5f 92       	push	r5
     ad0:	6f 92       	push	r6
     ad2:	7f 92       	push	r7
     ad4:	8f 92       	push	r8
     ad6:	9f 92       	push	r9
     ad8:	af 92       	push	r10
     ada:	bf 92       	push	r11
     adc:	cf 92       	push	r12
     ade:	df 92       	push	r13
     ae0:	ef 92       	push	r14
     ae2:	ff 92       	push	r15
     ae4:	0f 93       	push	r16
     ae6:	1f 93       	push	r17
     ae8:	2f 93       	push	r18
     aea:	3f 93       	push	r19
     aec:	4f 93       	push	r20
     aee:	5f 93       	push	r21
     af0:	6f 93       	push	r22
     af2:	7f 93       	push	r23
     af4:	8f 93       	push	r24
     af6:	9f 93       	push	r25
     af8:	af 93       	push	r26
     afa:	bf 93       	push	r27
     afc:	cf 93       	push	r28
     afe:	df 93       	push	r29
     b00:	ef 93       	push	r30
     b02:	ff 93       	push	r31
     b04:	a0 91 ee 07 	lds	r26, 0x07EE	; 0x8007ee <pxCurrentTCB>
     b08:	b0 91 ef 07 	lds	r27, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
     b0c:	0d b6       	in	r0, 0x3d	; 61
     b0e:	0d 92       	st	X+, r0
     b10:	0e b6       	in	r0, 0x3e	; 62
     b12:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     b14:	72 d3       	rcall	.+1764   	; 0x11fa <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     b16:	a0 91 ee 07 	lds	r26, 0x07EE	; 0x8007ee <pxCurrentTCB>
     b1a:	b0 91 ef 07 	lds	r27, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
     b1e:	cd 91       	ld	r28, X+
     b20:	cd bf       	out	0x3d, r28	; 61
     b22:	dd 91       	ld	r29, X+
     b24:	de bf       	out	0x3e, r29	; 62
     b26:	ff 91       	pop	r31
     b28:	ef 91       	pop	r30
     b2a:	df 91       	pop	r29
     b2c:	cf 91       	pop	r28
     b2e:	bf 91       	pop	r27
     b30:	af 91       	pop	r26
     b32:	9f 91       	pop	r25
     b34:	8f 91       	pop	r24
     b36:	7f 91       	pop	r23
     b38:	6f 91       	pop	r22
     b3a:	5f 91       	pop	r21
     b3c:	4f 91       	pop	r20
     b3e:	3f 91       	pop	r19
     b40:	2f 91       	pop	r18
     b42:	1f 91       	pop	r17
     b44:	0f 91       	pop	r16
     b46:	ff 90       	pop	r15
     b48:	ef 90       	pop	r14
     b4a:	df 90       	pop	r13
     b4c:	cf 90       	pop	r12
     b4e:	bf 90       	pop	r11
     b50:	af 90       	pop	r10
     b52:	9f 90       	pop	r9
     b54:	8f 90       	pop	r8
     b56:	7f 90       	pop	r7
     b58:	6f 90       	pop	r6
     b5a:	5f 90       	pop	r5
     b5c:	4f 90       	pop	r4
     b5e:	3f 90       	pop	r3
     b60:	2f 90       	pop	r2
     b62:	1f 90       	pop	r1
     b64:	0f 90       	pop	r0
     b66:	0f be       	out	0x3f, r0	; 63
     b68:	0f 90       	pop	r0

	asm volatile ( "ret" );
     b6a:	08 95       	ret

00000b6c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     b6c:	0f 92       	push	r0
     b6e:	0f b6       	in	r0, 0x3f	; 63
     b70:	f8 94       	cli
     b72:	0f 92       	push	r0
     b74:	1f 92       	push	r1
     b76:	11 24       	eor	r1, r1
     b78:	2f 92       	push	r2
     b7a:	3f 92       	push	r3
     b7c:	4f 92       	push	r4
     b7e:	5f 92       	push	r5
     b80:	6f 92       	push	r6
     b82:	7f 92       	push	r7
     b84:	8f 92       	push	r8
     b86:	9f 92       	push	r9
     b88:	af 92       	push	r10
     b8a:	bf 92       	push	r11
     b8c:	cf 92       	push	r12
     b8e:	df 92       	push	r13
     b90:	ef 92       	push	r14
     b92:	ff 92       	push	r15
     b94:	0f 93       	push	r16
     b96:	1f 93       	push	r17
     b98:	2f 93       	push	r18
     b9a:	3f 93       	push	r19
     b9c:	4f 93       	push	r20
     b9e:	5f 93       	push	r21
     ba0:	6f 93       	push	r22
     ba2:	7f 93       	push	r23
     ba4:	8f 93       	push	r24
     ba6:	9f 93       	push	r25
     ba8:	af 93       	push	r26
     baa:	bf 93       	push	r27
     bac:	cf 93       	push	r28
     bae:	df 93       	push	r29
     bb0:	ef 93       	push	r30
     bb2:	ff 93       	push	r31
     bb4:	a0 91 ee 07 	lds	r26, 0x07EE	; 0x8007ee <pxCurrentTCB>
     bb8:	b0 91 ef 07 	lds	r27, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
     bbc:	0d b6       	in	r0, 0x3d	; 61
     bbe:	0d 92       	st	X+, r0
     bc0:	0e b6       	in	r0, 0x3e	; 62
     bc2:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     bc4:	85 d1       	rcall	.+778    	; 0xed0 <vTaskIncrementTick>
	vTaskSwitchContext();
     bc6:	19 d3       	rcall	.+1586   	; 0x11fa <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     bc8:	a0 91 ee 07 	lds	r26, 0x07EE	; 0x8007ee <pxCurrentTCB>
     bcc:	b0 91 ef 07 	lds	r27, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
     bd0:	cd 91       	ld	r28, X+
     bd2:	cd bf       	out	0x3d, r28	; 61
     bd4:	dd 91       	ld	r29, X+
     bd6:	de bf       	out	0x3e, r29	; 62
     bd8:	ff 91       	pop	r31
     bda:	ef 91       	pop	r30
     bdc:	df 91       	pop	r29
     bde:	cf 91       	pop	r28
     be0:	bf 91       	pop	r27
     be2:	af 91       	pop	r26
     be4:	9f 91       	pop	r25
     be6:	8f 91       	pop	r24
     be8:	7f 91       	pop	r23
     bea:	6f 91       	pop	r22
     bec:	5f 91       	pop	r21
     bee:	4f 91       	pop	r20
     bf0:	3f 91       	pop	r19
     bf2:	2f 91       	pop	r18
     bf4:	1f 91       	pop	r17
     bf6:	0f 91       	pop	r16
     bf8:	ff 90       	pop	r15
     bfa:	ef 90       	pop	r14
     bfc:	df 90       	pop	r13
     bfe:	cf 90       	pop	r12
     c00:	bf 90       	pop	r11
     c02:	af 90       	pop	r10
     c04:	9f 90       	pop	r9
     c06:	8f 90       	pop	r8
     c08:	7f 90       	pop	r7
     c0a:	6f 90       	pop	r6
     c0c:	5f 90       	pop	r5
     c0e:	4f 90       	pop	r4
     c10:	3f 90       	pop	r3
     c12:	2f 90       	pop	r2
     c14:	1f 90       	pop	r1
     c16:	0f 90       	pop	r0
     c18:	0f be       	out	0x3f, r0	; 63
     c1a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     c1c:	08 95       	ret

00000c1e <__vector_13>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     c1e:	a6 df       	rcall	.-180    	; 0xb6c <vPortYieldFromTick>
		asm volatile ( "reti" );
     c20:	18 95       	reti

00000c22 <prvAddCurrentTaskToDelayedList>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
     c22:	cf 93       	push	r28
     c24:	df 93       	push	r29
     c26:	ec 01       	movw	r28, r24
     c28:	e0 91 ee 07 	lds	r30, 0x07EE	; 0x8007ee <pxCurrentTCB>
     c2c:	f0 91 ef 07 	lds	r31, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
     c30:	93 83       	std	Z+3, r25	; 0x03
     c32:	82 83       	std	Z+2, r24	; 0x02
     c34:	80 91 9e 07 	lds	r24, 0x079E	; 0x80079e <xTickCount>
     c38:	90 91 9f 07 	lds	r25, 0x079F	; 0x80079f <xTickCount+0x1>
     c3c:	c8 17       	cp	r28, r24
     c3e:	d9 07       	cpc	r29, r25
     c40:	60 f4       	brcc	.+24     	; 0xc5a <prvAddCurrentTaskToDelayedList+0x38>
     c42:	60 91 ee 07 	lds	r22, 0x07EE	; 0x8007ee <pxCurrentTCB>
     c46:	70 91 ef 07 	lds	r23, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
     c4a:	80 91 b4 07 	lds	r24, 0x07B4	; 0x8007b4 <pxOverflowDelayedTaskList>
     c4e:	90 91 b5 07 	lds	r25, 0x07B5	; 0x8007b5 <pxOverflowDelayedTaskList+0x1>
     c52:	6e 5f       	subi	r22, 0xFE	; 254
     c54:	7f 4f       	sbci	r23, 0xFF	; 255
     c56:	97 da       	rcall	.-2770   	; 0x186 <vListInsert>
     c58:	16 c0       	rjmp	.+44     	; 0xc86 <prvAddCurrentTaskToDelayedList+0x64>
     c5a:	60 91 ee 07 	lds	r22, 0x07EE	; 0x8007ee <pxCurrentTCB>
     c5e:	70 91 ef 07 	lds	r23, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
     c62:	80 91 b6 07 	lds	r24, 0x07B6	; 0x8007b6 <pxDelayedTaskList>
     c66:	90 91 b7 07 	lds	r25, 0x07B7	; 0x8007b7 <pxDelayedTaskList+0x1>
     c6a:	6e 5f       	subi	r22, 0xFE	; 254
     c6c:	7f 4f       	sbci	r23, 0xFF	; 255
     c6e:	8b da       	rcall	.-2794   	; 0x186 <vListInsert>
     c70:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <xNextTaskUnblockTime>
     c74:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <xNextTaskUnblockTime+0x1>
     c78:	c8 17       	cp	r28, r24
     c7a:	d9 07       	cpc	r29, r25
     c7c:	20 f4       	brcc	.+8      	; 0xc86 <prvAddCurrentTaskToDelayedList+0x64>
     c7e:	d0 93 33 01 	sts	0x0133, r29	; 0x800133 <xNextTaskUnblockTime+0x1>
     c82:	c0 93 32 01 	sts	0x0132, r28	; 0x800132 <xNextTaskUnblockTime>
     c86:	df 91       	pop	r29
     c88:	cf 91       	pop	r28
     c8a:	08 95       	ret

00000c8c <xTaskGenericCreate>:
     c8c:	4f 92       	push	r4
     c8e:	5f 92       	push	r5
     c90:	6f 92       	push	r6
     c92:	7f 92       	push	r7
     c94:	8f 92       	push	r8
     c96:	9f 92       	push	r9
     c98:	af 92       	push	r10
     c9a:	bf 92       	push	r11
     c9c:	cf 92       	push	r12
     c9e:	df 92       	push	r13
     ca0:	ef 92       	push	r14
     ca2:	ff 92       	push	r15
     ca4:	0f 93       	push	r16
     ca6:	1f 93       	push	r17
     ca8:	cf 93       	push	r28
     caa:	df 93       	push	r29
     cac:	5c 01       	movw	r10, r24
     cae:	4b 01       	movw	r8, r22
     cb0:	3a 01       	movw	r6, r20
     cb2:	29 01       	movw	r4, r18
     cb4:	81 e2       	ldi	r24, 0x21	; 33
     cb6:	90 e0       	ldi	r25, 0x00	; 0
     cb8:	08 da       	rcall	.-3056   	; 0xca <pvPortMalloc>
     cba:	ec 01       	movw	r28, r24
     cbc:	89 2b       	or	r24, r25
     cbe:	09 f4       	brne	.+2      	; 0xcc2 <xTaskGenericCreate+0x36>
     cc0:	c6 c0       	rjmp	.+396    	; 0xe4e <xTaskGenericCreate+0x1c2>
     cc2:	c1 14       	cp	r12, r1
     cc4:	d1 04       	cpc	r13, r1
     cc6:	09 f0       	breq	.+2      	; 0xcca <xTaskGenericCreate+0x3e>
     cc8:	be c0       	rjmp	.+380    	; 0xe46 <xTaskGenericCreate+0x1ba>
     cca:	c3 01       	movw	r24, r6
     ccc:	fe d9       	rcall	.-3076   	; 0xca <pvPortMalloc>
     cce:	98 8f       	std	Y+24, r25	; 0x18
     cd0:	8f 8b       	std	Y+23, r24	; 0x17
     cd2:	00 97       	sbiw	r24, 0x00	; 0
     cd4:	19 f4       	brne	.+6      	; 0xcdc <xTaskGenericCreate+0x50>
     cd6:	ce 01       	movw	r24, r28
     cd8:	1c da       	rcall	.-3016   	; 0x112 <vPortFree>
     cda:	b9 c0       	rjmp	.+370    	; 0xe4e <xTaskGenericCreate+0x1c2>
     cdc:	a3 01       	movw	r20, r6
     cde:	65 ea       	ldi	r22, 0xA5	; 165
     ce0:	70 e0       	ldi	r23, 0x00	; 0
     ce2:	03 d3       	rcall	.+1542   	; 0x12ea <memset>
     ce4:	93 01       	movw	r18, r6
     ce6:	21 50       	subi	r18, 0x01	; 1
     ce8:	31 09       	sbc	r19, r1
     cea:	8f 89       	ldd	r24, Y+23	; 0x17
     cec:	98 8d       	ldd	r25, Y+24	; 0x18
     cee:	3c 01       	movw	r6, r24
     cf0:	62 0e       	add	r6, r18
     cf2:	73 1e       	adc	r7, r19
     cf4:	48 e0       	ldi	r20, 0x08	; 8
     cf6:	50 e0       	ldi	r21, 0x00	; 0
     cf8:	b4 01       	movw	r22, r8
     cfa:	ce 01       	movw	r24, r28
     cfc:	49 96       	adiw	r24, 0x19	; 25
     cfe:	fc d2       	rcall	.+1528   	; 0x12f8 <strncpy>
     d00:	18 a2       	std	Y+32, r1	; 0x20
     d02:	10 2f       	mov	r17, r16
     d04:	04 30       	cpi	r16, 0x04	; 4
     d06:	08 f0       	brcs	.+2      	; 0xd0a <xTaskGenericCreate+0x7e>
     d08:	13 e0       	ldi	r17, 0x03	; 3
     d0a:	1e 8b       	std	Y+22, r17	; 0x16
     d0c:	6e 01       	movw	r12, r28
     d0e:	82 e0       	ldi	r24, 0x02	; 2
     d10:	c8 0e       	add	r12, r24
     d12:	d1 1c       	adc	r13, r1
     d14:	c6 01       	movw	r24, r12
     d16:	0c da       	rcall	.-3048   	; 0x130 <vListInitialiseItem>
     d18:	ce 01       	movw	r24, r28
     d1a:	0c 96       	adiw	r24, 0x0c	; 12
     d1c:	09 da       	rcall	.-3054   	; 0x130 <vListInitialiseItem>
     d1e:	d9 87       	std	Y+9, r29	; 0x09
     d20:	c8 87       	std	Y+8, r28	; 0x08
     d22:	84 e0       	ldi	r24, 0x04	; 4
     d24:	90 e0       	ldi	r25, 0x00	; 0
     d26:	81 1b       	sub	r24, r17
     d28:	91 09       	sbc	r25, r1
     d2a:	9d 87       	std	Y+13, r25	; 0x0d
     d2c:	8c 87       	std	Y+12, r24	; 0x0c
     d2e:	db 8b       	std	Y+19, r29	; 0x13
     d30:	ca 8b       	std	Y+18, r28	; 0x12
     d32:	a2 01       	movw	r20, r4
     d34:	b5 01       	movw	r22, r10
     d36:	c3 01       	movw	r24, r6
     d38:	1b de       	rcall	.-970    	; 0x970 <pxPortInitialiseStack>
     d3a:	99 83       	std	Y+1, r25	; 0x01
     d3c:	88 83       	st	Y, r24
     d3e:	e1 14       	cp	r14, r1
     d40:	f1 04       	cpc	r15, r1
     d42:	19 f0       	breq	.+6      	; 0xd4a <xTaskGenericCreate+0xbe>
     d44:	f7 01       	movw	r30, r14
     d46:	d1 83       	std	Z+1, r29	; 0x01
     d48:	c0 83       	st	Z, r28
     d4a:	0f b6       	in	r0, 0x3f	; 63
     d4c:	f8 94       	cli
     d4e:	0f 92       	push	r0
     d50:	80 91 a0 07 	lds	r24, 0x07A0	; 0x8007a0 <uxCurrentNumberOfTasks>
     d54:	8f 5f       	subi	r24, 0xFF	; 255
     d56:	80 93 a0 07 	sts	0x07A0, r24	; 0x8007a0 <uxCurrentNumberOfTasks>
     d5a:	80 91 ee 07 	lds	r24, 0x07EE	; 0x8007ee <pxCurrentTCB>
     d5e:	90 91 ef 07 	lds	r25, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
     d62:	89 2b       	or	r24, r25
     d64:	69 f5       	brne	.+90     	; 0xdc0 <xTaskGenericCreate+0x134>
     d66:	d0 93 ef 07 	sts	0x07EF, r29	; 0x8007ef <pxCurrentTCB+0x1>
     d6a:	c0 93 ee 07 	sts	0x07EE, r28	; 0x8007ee <pxCurrentTCB>
     d6e:	80 91 a0 07 	lds	r24, 0x07A0	; 0x8007a0 <uxCurrentNumberOfTasks>
     d72:	81 30       	cpi	r24, 0x01	; 1
     d74:	a1 f5       	brne	.+104    	; 0xdde <xTaskGenericCreate+0x152>
     d76:	8a ec       	ldi	r24, 0xCA	; 202
     d78:	97 e0       	ldi	r25, 0x07	; 7
     d7a:	cc d9       	rcall	.-3176   	; 0x114 <vListInitialise>
     d7c:	83 ed       	ldi	r24, 0xD3	; 211
     d7e:	97 e0       	ldi	r25, 0x07	; 7
     d80:	c9 d9       	rcall	.-3182   	; 0x114 <vListInitialise>
     d82:	8c ed       	ldi	r24, 0xDC	; 220
     d84:	97 e0       	ldi	r25, 0x07	; 7
     d86:	c6 d9       	rcall	.-3188   	; 0x114 <vListInitialise>
     d88:	85 ee       	ldi	r24, 0xE5	; 229
     d8a:	97 e0       	ldi	r25, 0x07	; 7
     d8c:	c3 d9       	rcall	.-3194   	; 0x114 <vListInitialise>
     d8e:	81 ec       	ldi	r24, 0xC1	; 193
     d90:	97 e0       	ldi	r25, 0x07	; 7
     d92:	c0 d9       	rcall	.-3200   	; 0x114 <vListInitialise>
     d94:	88 eb       	ldi	r24, 0xB8	; 184
     d96:	97 e0       	ldi	r25, 0x07	; 7
     d98:	bd d9       	rcall	.-3206   	; 0x114 <vListInitialise>
     d9a:	8b ea       	ldi	r24, 0xAB	; 171
     d9c:	97 e0       	ldi	r25, 0x07	; 7
     d9e:	ba d9       	rcall	.-3212   	; 0x114 <vListInitialise>
     da0:	82 ea       	ldi	r24, 0xA2	; 162
     da2:	97 e0       	ldi	r25, 0x07	; 7
     da4:	b7 d9       	rcall	.-3218   	; 0x114 <vListInitialise>
     da6:	81 ec       	ldi	r24, 0xC1	; 193
     da8:	97 e0       	ldi	r25, 0x07	; 7
     daa:	90 93 b7 07 	sts	0x07B7, r25	; 0x8007b7 <pxDelayedTaskList+0x1>
     dae:	80 93 b6 07 	sts	0x07B6, r24	; 0x8007b6 <pxDelayedTaskList>
     db2:	88 eb       	ldi	r24, 0xB8	; 184
     db4:	97 e0       	ldi	r25, 0x07	; 7
     db6:	90 93 b5 07 	sts	0x07B5, r25	; 0x8007b5 <pxOverflowDelayedTaskList+0x1>
     dba:	80 93 b4 07 	sts	0x07B4, r24	; 0x8007b4 <pxOverflowDelayedTaskList>
     dbe:	0f c0       	rjmp	.+30     	; 0xdde <xTaskGenericCreate+0x152>
     dc0:	80 91 9b 07 	lds	r24, 0x079B	; 0x80079b <xSchedulerRunning>
     dc4:	81 11       	cpse	r24, r1
     dc6:	0b c0       	rjmp	.+22     	; 0xdde <xTaskGenericCreate+0x152>
     dc8:	e0 91 ee 07 	lds	r30, 0x07EE	; 0x8007ee <pxCurrentTCB>
     dcc:	f0 91 ef 07 	lds	r31, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
     dd0:	86 89       	ldd	r24, Z+22	; 0x16
     dd2:	08 17       	cp	r16, r24
     dd4:	20 f0       	brcs	.+8      	; 0xdde <xTaskGenericCreate+0x152>
     dd6:	d0 93 ef 07 	sts	0x07EF, r29	; 0x8007ef <pxCurrentTCB+0x1>
     dda:	c0 93 ee 07 	sts	0x07EE, r28	; 0x8007ee <pxCurrentTCB>
     dde:	8e 89       	ldd	r24, Y+22	; 0x16
     de0:	90 91 9d 07 	lds	r25, 0x079D	; 0x80079d <uxTopUsedPriority>
     de4:	98 17       	cp	r25, r24
     de6:	10 f4       	brcc	.+4      	; 0xdec <xTaskGenericCreate+0x160>
     de8:	80 93 9d 07 	sts	0x079D, r24	; 0x80079d <uxTopUsedPriority>
     dec:	90 91 96 07 	lds	r25, 0x0796	; 0x800796 <uxTaskNumber>
     df0:	9f 5f       	subi	r25, 0xFF	; 255
     df2:	90 93 96 07 	sts	0x0796, r25	; 0x800796 <uxTaskNumber>
     df6:	90 91 9c 07 	lds	r25, 0x079C	; 0x80079c <uxTopReadyPriority>
     dfa:	98 17       	cp	r25, r24
     dfc:	10 f4       	brcc	.+4      	; 0xe02 <xTaskGenericCreate+0x176>
     dfe:	80 93 9c 07 	sts	0x079C, r24	; 0x80079c <uxTopReadyPriority>
     e02:	90 e0       	ldi	r25, 0x00	; 0
     e04:	9c 01       	movw	r18, r24
     e06:	22 0f       	add	r18, r18
     e08:	33 1f       	adc	r19, r19
     e0a:	22 0f       	add	r18, r18
     e0c:	33 1f       	adc	r19, r19
     e0e:	22 0f       	add	r18, r18
     e10:	33 1f       	adc	r19, r19
     e12:	82 0f       	add	r24, r18
     e14:	93 1f       	adc	r25, r19
     e16:	b6 01       	movw	r22, r12
     e18:	86 53       	subi	r24, 0x36	; 54
     e1a:	98 4f       	sbci	r25, 0xF8	; 248
     e1c:	8d d9       	rcall	.-3302   	; 0x138 <vListInsertEnd>
     e1e:	0f 90       	pop	r0
     e20:	0f be       	out	0x3f, r0	; 63
     e22:	80 91 9b 07 	lds	r24, 0x079B	; 0x80079b <xSchedulerRunning>
     e26:	88 23       	and	r24, r24
     e28:	51 f0       	breq	.+20     	; 0xe3e <xTaskGenericCreate+0x1b2>
     e2a:	e0 91 ee 07 	lds	r30, 0x07EE	; 0x8007ee <pxCurrentTCB>
     e2e:	f0 91 ef 07 	lds	r31, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
     e32:	86 89       	ldd	r24, Z+22	; 0x16
     e34:	80 17       	cp	r24, r16
     e36:	28 f4       	brcc	.+10     	; 0xe42 <xTaskGenericCreate+0x1b6>
     e38:	41 de       	rcall	.-894    	; 0xabc <vPortYield>
     e3a:	81 e0       	ldi	r24, 0x01	; 1
     e3c:	09 c0       	rjmp	.+18     	; 0xe50 <xTaskGenericCreate+0x1c4>
     e3e:	81 e0       	ldi	r24, 0x01	; 1
     e40:	07 c0       	rjmp	.+14     	; 0xe50 <xTaskGenericCreate+0x1c4>
     e42:	81 e0       	ldi	r24, 0x01	; 1
     e44:	05 c0       	rjmp	.+10     	; 0xe50 <xTaskGenericCreate+0x1c4>
     e46:	d8 8e       	std	Y+24, r13	; 0x18
     e48:	cf 8a       	std	Y+23, r12	; 0x17
     e4a:	c6 01       	movw	r24, r12
     e4c:	47 cf       	rjmp	.-370    	; 0xcdc <xTaskGenericCreate+0x50>
     e4e:	8f ef       	ldi	r24, 0xFF	; 255
     e50:	df 91       	pop	r29
     e52:	cf 91       	pop	r28
     e54:	1f 91       	pop	r17
     e56:	0f 91       	pop	r16
     e58:	ff 90       	pop	r15
     e5a:	ef 90       	pop	r14
     e5c:	df 90       	pop	r13
     e5e:	cf 90       	pop	r12
     e60:	bf 90       	pop	r11
     e62:	af 90       	pop	r10
     e64:	9f 90       	pop	r9
     e66:	8f 90       	pop	r8
     e68:	7f 90       	pop	r7
     e6a:	6f 90       	pop	r6
     e6c:	5f 90       	pop	r5
     e6e:	4f 90       	pop	r4
     e70:	08 95       	ret

00000e72 <vTaskStartScheduler>:
     e72:	af 92       	push	r10
     e74:	bf 92       	push	r11
     e76:	cf 92       	push	r12
     e78:	df 92       	push	r13
     e7a:	ef 92       	push	r14
     e7c:	ff 92       	push	r15
     e7e:	0f 93       	push	r16
     e80:	a1 2c       	mov	r10, r1
     e82:	b1 2c       	mov	r11, r1
     e84:	c1 2c       	mov	r12, r1
     e86:	d1 2c       	mov	r13, r1
     e88:	e1 2c       	mov	r14, r1
     e8a:	f1 2c       	mov	r15, r1
     e8c:	00 e0       	ldi	r16, 0x00	; 0
     e8e:	20 e0       	ldi	r18, 0x00	; 0
     e90:	30 e0       	ldi	r19, 0x00	; 0
     e92:	45 e5       	ldi	r20, 0x55	; 85
     e94:	50 e0       	ldi	r21, 0x00	; 0
     e96:	6c e9       	ldi	r22, 0x9C	; 156
     e98:	71 e0       	ldi	r23, 0x01	; 1
     e9a:	85 ec       	ldi	r24, 0xC5	; 197
     e9c:	98 e0       	ldi	r25, 0x08	; 8
     e9e:	f6 de       	rcall	.-532    	; 0xc8c <xTaskGenericCreate>
     ea0:	81 30       	cpi	r24, 0x01	; 1
     ea2:	41 f4       	brne	.+16     	; 0xeb4 <vTaskStartScheduler+0x42>
     ea4:	f8 94       	cli
     ea6:	80 93 9b 07 	sts	0x079B, r24	; 0x80079b <xSchedulerRunning>
     eaa:	10 92 9f 07 	sts	0x079F, r1	; 0x80079f <xTickCount+0x1>
     eae:	10 92 9e 07 	sts	0x079E, r1	; 0x80079e <xTickCount>
     eb2:	ca dd       	rcall	.-1132   	; 0xa48 <xPortStartScheduler>
     eb4:	0f 91       	pop	r16
     eb6:	ff 90       	pop	r15
     eb8:	ef 90       	pop	r14
     eba:	df 90       	pop	r13
     ebc:	cf 90       	pop	r12
     ebe:	bf 90       	pop	r11
     ec0:	af 90       	pop	r10
     ec2:	08 95       	ret

00000ec4 <vTaskSuspendAll>:
     ec4:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <uxSchedulerSuspended>
     ec8:	8f 5f       	subi	r24, 0xFF	; 255
     eca:	80 93 9a 07 	sts	0x079A, r24	; 0x80079a <uxSchedulerSuspended>
     ece:	08 95       	ret

00000ed0 <vTaskIncrementTick>:
     ed0:	0f 93       	push	r16
     ed2:	1f 93       	push	r17
     ed4:	cf 93       	push	r28
     ed6:	df 93       	push	r29
     ed8:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <uxSchedulerSuspended>
     edc:	81 11       	cpse	r24, r1
     ede:	af c0       	rjmp	.+350    	; 0x103e <vTaskIncrementTick+0x16e>
     ee0:	80 91 9e 07 	lds	r24, 0x079E	; 0x80079e <xTickCount>
     ee4:	90 91 9f 07 	lds	r25, 0x079F	; 0x80079f <xTickCount+0x1>
     ee8:	01 96       	adiw	r24, 0x01	; 1
     eea:	90 93 9f 07 	sts	0x079F, r25	; 0x80079f <xTickCount+0x1>
     eee:	80 93 9e 07 	sts	0x079E, r24	; 0x80079e <xTickCount>
     ef2:	80 91 9e 07 	lds	r24, 0x079E	; 0x80079e <xTickCount>
     ef6:	90 91 9f 07 	lds	r25, 0x079F	; 0x80079f <xTickCount+0x1>
     efa:	89 2b       	or	r24, r25
     efc:	99 f5       	brne	.+102    	; 0xf64 <vTaskIncrementTick+0x94>
     efe:	80 91 b6 07 	lds	r24, 0x07B6	; 0x8007b6 <pxDelayedTaskList>
     f02:	90 91 b7 07 	lds	r25, 0x07B7	; 0x8007b7 <pxDelayedTaskList+0x1>
     f06:	20 91 b4 07 	lds	r18, 0x07B4	; 0x8007b4 <pxOverflowDelayedTaskList>
     f0a:	30 91 b5 07 	lds	r19, 0x07B5	; 0x8007b5 <pxOverflowDelayedTaskList+0x1>
     f0e:	30 93 b7 07 	sts	0x07B7, r19	; 0x8007b7 <pxDelayedTaskList+0x1>
     f12:	20 93 b6 07 	sts	0x07B6, r18	; 0x8007b6 <pxDelayedTaskList>
     f16:	90 93 b5 07 	sts	0x07B5, r25	; 0x8007b5 <pxOverflowDelayedTaskList+0x1>
     f1a:	80 93 b4 07 	sts	0x07B4, r24	; 0x8007b4 <pxOverflowDelayedTaskList>
     f1e:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <xNumOfOverflows>
     f22:	8f 5f       	subi	r24, 0xFF	; 255
     f24:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <xNumOfOverflows>
     f28:	e0 91 b6 07 	lds	r30, 0x07B6	; 0x8007b6 <pxDelayedTaskList>
     f2c:	f0 91 b7 07 	lds	r31, 0x07B7	; 0x8007b7 <pxDelayedTaskList+0x1>
     f30:	80 81       	ld	r24, Z
     f32:	81 11       	cpse	r24, r1
     f34:	07 c0       	rjmp	.+14     	; 0xf44 <vTaskIncrementTick+0x74>
     f36:	8f ef       	ldi	r24, 0xFF	; 255
     f38:	9f ef       	ldi	r25, 0xFF	; 255
     f3a:	90 93 33 01 	sts	0x0133, r25	; 0x800133 <xNextTaskUnblockTime+0x1>
     f3e:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <xNextTaskUnblockTime>
     f42:	10 c0       	rjmp	.+32     	; 0xf64 <vTaskIncrementTick+0x94>
     f44:	e0 91 b6 07 	lds	r30, 0x07B6	; 0x8007b6 <pxDelayedTaskList>
     f48:	f0 91 b7 07 	lds	r31, 0x07B7	; 0x8007b7 <pxDelayedTaskList+0x1>
     f4c:	05 80       	ldd	r0, Z+5	; 0x05
     f4e:	f6 81       	ldd	r31, Z+6	; 0x06
     f50:	e0 2d       	mov	r30, r0
     f52:	06 80       	ldd	r0, Z+6	; 0x06
     f54:	f7 81       	ldd	r31, Z+7	; 0x07
     f56:	e0 2d       	mov	r30, r0
     f58:	82 81       	ldd	r24, Z+2	; 0x02
     f5a:	93 81       	ldd	r25, Z+3	; 0x03
     f5c:	90 93 33 01 	sts	0x0133, r25	; 0x800133 <xNextTaskUnblockTime+0x1>
     f60:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <xNextTaskUnblockTime>
     f64:	20 91 9e 07 	lds	r18, 0x079E	; 0x80079e <xTickCount>
     f68:	30 91 9f 07 	lds	r19, 0x079F	; 0x80079f <xTickCount+0x1>
     f6c:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <xNextTaskUnblockTime>
     f70:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <xNextTaskUnblockTime+0x1>
     f74:	28 17       	cp	r18, r24
     f76:	39 07       	cpc	r19, r25
     f78:	08 f4       	brcc	.+2      	; 0xf7c <vTaskIncrementTick+0xac>
     f7a:	66 c0       	rjmp	.+204    	; 0x1048 <vTaskIncrementTick+0x178>
     f7c:	e0 91 b6 07 	lds	r30, 0x07B6	; 0x8007b6 <pxDelayedTaskList>
     f80:	f0 91 b7 07 	lds	r31, 0x07B7	; 0x8007b7 <pxDelayedTaskList+0x1>
     f84:	80 81       	ld	r24, Z
     f86:	88 23       	and	r24, r24
     f88:	99 f0       	breq	.+38     	; 0xfb0 <vTaskIncrementTick+0xe0>
     f8a:	e0 91 b6 07 	lds	r30, 0x07B6	; 0x8007b6 <pxDelayedTaskList>
     f8e:	f0 91 b7 07 	lds	r31, 0x07B7	; 0x8007b7 <pxDelayedTaskList+0x1>
     f92:	05 80       	ldd	r0, Z+5	; 0x05
     f94:	f6 81       	ldd	r31, Z+6	; 0x06
     f96:	e0 2d       	mov	r30, r0
     f98:	c6 81       	ldd	r28, Z+6	; 0x06
     f9a:	d7 81       	ldd	r29, Z+7	; 0x07
     f9c:	8a 81       	ldd	r24, Y+2	; 0x02
     f9e:	9b 81       	ldd	r25, Y+3	; 0x03
     fa0:	20 91 9e 07 	lds	r18, 0x079E	; 0x80079e <xTickCount>
     fa4:	30 91 9f 07 	lds	r19, 0x079F	; 0x80079f <xTickCount+0x1>
     fa8:	28 17       	cp	r18, r24
     faa:	39 07       	cpc	r19, r25
     fac:	f8 f4       	brcc	.+62     	; 0xfec <vTaskIncrementTick+0x11c>
     fae:	19 c0       	rjmp	.+50     	; 0xfe2 <vTaskIncrementTick+0x112>
     fb0:	8f ef       	ldi	r24, 0xFF	; 255
     fb2:	9f ef       	ldi	r25, 0xFF	; 255
     fb4:	90 93 33 01 	sts	0x0133, r25	; 0x800133 <xNextTaskUnblockTime+0x1>
     fb8:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <xNextTaskUnblockTime>
     fbc:	45 c0       	rjmp	.+138    	; 0x1048 <vTaskIncrementTick+0x178>
     fbe:	e0 91 b6 07 	lds	r30, 0x07B6	; 0x8007b6 <pxDelayedTaskList>
     fc2:	f0 91 b7 07 	lds	r31, 0x07B7	; 0x8007b7 <pxDelayedTaskList+0x1>
     fc6:	05 80       	ldd	r0, Z+5	; 0x05
     fc8:	f6 81       	ldd	r31, Z+6	; 0x06
     fca:	e0 2d       	mov	r30, r0
     fcc:	c6 81       	ldd	r28, Z+6	; 0x06
     fce:	d7 81       	ldd	r29, Z+7	; 0x07
     fd0:	8a 81       	ldd	r24, Y+2	; 0x02
     fd2:	9b 81       	ldd	r25, Y+3	; 0x03
     fd4:	20 91 9e 07 	lds	r18, 0x079E	; 0x80079e <xTickCount>
     fd8:	30 91 9f 07 	lds	r19, 0x079F	; 0x80079f <xTickCount+0x1>
     fdc:	28 17       	cp	r18, r24
     fde:	39 07       	cpc	r19, r25
     fe0:	28 f4       	brcc	.+10     	; 0xfec <vTaskIncrementTick+0x11c>
     fe2:	90 93 33 01 	sts	0x0133, r25	; 0x800133 <xNextTaskUnblockTime+0x1>
     fe6:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <xNextTaskUnblockTime>
     fea:	2e c0       	rjmp	.+92     	; 0x1048 <vTaskIncrementTick+0x178>
     fec:	8e 01       	movw	r16, r28
     fee:	0e 5f       	subi	r16, 0xFE	; 254
     ff0:	1f 4f       	sbci	r17, 0xFF	; 255
     ff2:	c8 01       	movw	r24, r16
     ff4:	03 d9       	rcall	.-3578   	; 0x1fc <vListRemove>
     ff6:	8c 89       	ldd	r24, Y+20	; 0x14
     ff8:	9d 89       	ldd	r25, Y+21	; 0x15
     ffa:	89 2b       	or	r24, r25
     ffc:	19 f0       	breq	.+6      	; 0x1004 <vTaskIncrementTick+0x134>
     ffe:	ce 01       	movw	r24, r28
    1000:	0c 96       	adiw	r24, 0x0c	; 12
    1002:	fc d8       	rcall	.-3592   	; 0x1fc <vListRemove>
    1004:	2e 89       	ldd	r18, Y+22	; 0x16
    1006:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxTopReadyPriority>
    100a:	82 17       	cp	r24, r18
    100c:	10 f4       	brcc	.+4      	; 0x1012 <vTaskIncrementTick+0x142>
    100e:	20 93 9c 07 	sts	0x079C, r18	; 0x80079c <uxTopReadyPriority>
    1012:	30 e0       	ldi	r19, 0x00	; 0
    1014:	c9 01       	movw	r24, r18
    1016:	88 0f       	add	r24, r24
    1018:	99 1f       	adc	r25, r25
    101a:	88 0f       	add	r24, r24
    101c:	99 1f       	adc	r25, r25
    101e:	88 0f       	add	r24, r24
    1020:	99 1f       	adc	r25, r25
    1022:	82 0f       	add	r24, r18
    1024:	93 1f       	adc	r25, r19
    1026:	b8 01       	movw	r22, r16
    1028:	86 53       	subi	r24, 0x36	; 54
    102a:	98 4f       	sbci	r25, 0xF8	; 248
    102c:	85 d8       	rcall	.-3830   	; 0x138 <vListInsertEnd>
    102e:	e0 91 b6 07 	lds	r30, 0x07B6	; 0x8007b6 <pxDelayedTaskList>
    1032:	f0 91 b7 07 	lds	r31, 0x07B7	; 0x8007b7 <pxDelayedTaskList+0x1>
    1036:	80 81       	ld	r24, Z
    1038:	81 11       	cpse	r24, r1
    103a:	c1 cf       	rjmp	.-126    	; 0xfbe <vTaskIncrementTick+0xee>
    103c:	b9 cf       	rjmp	.-142    	; 0xfb0 <vTaskIncrementTick+0xe0>
    103e:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <uxMissedTicks>
    1042:	8f 5f       	subi	r24, 0xFF	; 255
    1044:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <uxMissedTicks>
    1048:	df 91       	pop	r29
    104a:	cf 91       	pop	r28
    104c:	1f 91       	pop	r17
    104e:	0f 91       	pop	r16
    1050:	08 95       	ret

00001052 <xTaskResumeAll>:
    1052:	cf 92       	push	r12
    1054:	df 92       	push	r13
    1056:	ef 92       	push	r14
    1058:	ff 92       	push	r15
    105a:	0f 93       	push	r16
    105c:	1f 93       	push	r17
    105e:	cf 93       	push	r28
    1060:	df 93       	push	r29
    1062:	0f b6       	in	r0, 0x3f	; 63
    1064:	f8 94       	cli
    1066:	0f 92       	push	r0
    1068:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <uxSchedulerSuspended>
    106c:	81 50       	subi	r24, 0x01	; 1
    106e:	80 93 9a 07 	sts	0x079A, r24	; 0x80079a <uxSchedulerSuspended>
    1072:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <uxSchedulerSuspended>
    1076:	81 11       	cpse	r24, r1
    1078:	5f c0       	rjmp	.+190    	; 0x1138 <xTaskResumeAll+0xe6>
    107a:	80 91 a0 07 	lds	r24, 0x07A0	; 0x8007a0 <uxCurrentNumberOfTasks>
    107e:	81 11       	cpse	r24, r1
    1080:	2f c0       	rjmp	.+94     	; 0x10e0 <xTaskResumeAll+0x8e>
    1082:	5d c0       	rjmp	.+186    	; 0x113e <xTaskResumeAll+0xec>
    1084:	d7 01       	movw	r26, r14
    1086:	15 96       	adiw	r26, 0x05	; 5
    1088:	ed 91       	ld	r30, X+
    108a:	fc 91       	ld	r31, X
    108c:	16 97       	sbiw	r26, 0x06	; 6
    108e:	c6 81       	ldd	r28, Z+6	; 0x06
    1090:	d7 81       	ldd	r29, Z+7	; 0x07
    1092:	ce 01       	movw	r24, r28
    1094:	0c 96       	adiw	r24, 0x0c	; 12
    1096:	b2 d8       	rcall	.-3740   	; 0x1fc <vListRemove>
    1098:	8e 01       	movw	r16, r28
    109a:	0e 5f       	subi	r16, 0xFE	; 254
    109c:	1f 4f       	sbci	r17, 0xFF	; 255
    109e:	c8 01       	movw	r24, r16
    10a0:	ad d8       	rcall	.-3750   	; 0x1fc <vListRemove>
    10a2:	2e 89       	ldd	r18, Y+22	; 0x16
    10a4:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxTopReadyPriority>
    10a8:	82 17       	cp	r24, r18
    10aa:	10 f4       	brcc	.+4      	; 0x10b0 <xTaskResumeAll+0x5e>
    10ac:	20 93 9c 07 	sts	0x079C, r18	; 0x80079c <uxTopReadyPriority>
    10b0:	30 e0       	ldi	r19, 0x00	; 0
    10b2:	c9 01       	movw	r24, r18
    10b4:	88 0f       	add	r24, r24
    10b6:	99 1f       	adc	r25, r25
    10b8:	88 0f       	add	r24, r24
    10ba:	99 1f       	adc	r25, r25
    10bc:	88 0f       	add	r24, r24
    10be:	99 1f       	adc	r25, r25
    10c0:	82 0f       	add	r24, r18
    10c2:	93 1f       	adc	r25, r19
    10c4:	b8 01       	movw	r22, r16
    10c6:	86 53       	subi	r24, 0x36	; 54
    10c8:	98 4f       	sbci	r25, 0xF8	; 248
    10ca:	36 d8       	rcall	.-3988   	; 0x138 <vListInsertEnd>
    10cc:	e0 91 ee 07 	lds	r30, 0x07EE	; 0x8007ee <pxCurrentTCB>
    10d0:	f0 91 ef 07 	lds	r31, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
    10d4:	9e 89       	ldd	r25, Y+22	; 0x16
    10d6:	86 89       	ldd	r24, Z+22	; 0x16
    10d8:	98 17       	cp	r25, r24
    10da:	58 f0       	brcs	.+22     	; 0x10f2 <xTaskResumeAll+0xa0>
    10dc:	dc 2c       	mov	r13, r12
    10de:	09 c0       	rjmp	.+18     	; 0x10f2 <xTaskResumeAll+0xa0>
    10e0:	d1 2c       	mov	r13, r1
    10e2:	0f 2e       	mov	r0, r31
    10e4:	fb ea       	ldi	r31, 0xAB	; 171
    10e6:	ef 2e       	mov	r14, r31
    10e8:	f7 e0       	ldi	r31, 0x07	; 7
    10ea:	ff 2e       	mov	r15, r31
    10ec:	f0 2d       	mov	r31, r0
    10ee:	cc 24       	eor	r12, r12
    10f0:	c3 94       	inc	r12
    10f2:	f7 01       	movw	r30, r14
    10f4:	80 81       	ld	r24, Z
    10f6:	81 11       	cpse	r24, r1
    10f8:	c5 cf       	rjmp	.-118    	; 0x1084 <xTaskResumeAll+0x32>
    10fa:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <uxMissedTicks>
    10fe:	88 23       	and	r24, r24
    1100:	79 f0       	breq	.+30     	; 0x1120 <xTaskResumeAll+0xce>
    1102:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <uxMissedTicks>
    1106:	88 23       	and	r24, r24
    1108:	91 f0       	breq	.+36     	; 0x112e <xTaskResumeAll+0xdc>
    110a:	e2 de       	rcall	.-572    	; 0xed0 <vTaskIncrementTick>
    110c:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <uxMissedTicks>
    1110:	81 50       	subi	r24, 0x01	; 1
    1112:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <uxMissedTicks>
    1116:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <uxMissedTicks>
    111a:	81 11       	cpse	r24, r1
    111c:	f6 cf       	rjmp	.-20     	; 0x110a <xTaskResumeAll+0xb8>
    111e:	07 c0       	rjmp	.+14     	; 0x112e <xTaskResumeAll+0xdc>
    1120:	f1 e0       	ldi	r31, 0x01	; 1
    1122:	df 16       	cp	r13, r31
    1124:	21 f0       	breq	.+8      	; 0x112e <xTaskResumeAll+0xdc>
    1126:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <xMissedYield>
    112a:	81 30       	cpi	r24, 0x01	; 1
    112c:	39 f4       	brne	.+14     	; 0x113c <xTaskResumeAll+0xea>
    112e:	10 92 98 07 	sts	0x0798, r1	; 0x800798 <xMissedYield>
    1132:	c4 dc       	rcall	.-1656   	; 0xabc <vPortYield>
    1134:	81 e0       	ldi	r24, 0x01	; 1
    1136:	03 c0       	rjmp	.+6      	; 0x113e <xTaskResumeAll+0xec>
    1138:	80 e0       	ldi	r24, 0x00	; 0
    113a:	01 c0       	rjmp	.+2      	; 0x113e <xTaskResumeAll+0xec>
    113c:	80 e0       	ldi	r24, 0x00	; 0
    113e:	0f 90       	pop	r0
    1140:	0f be       	out	0x3f, r0	; 63
    1142:	df 91       	pop	r29
    1144:	cf 91       	pop	r28
    1146:	1f 91       	pop	r17
    1148:	0f 91       	pop	r16
    114a:	ff 90       	pop	r15
    114c:	ef 90       	pop	r14
    114e:	df 90       	pop	r13
    1150:	cf 90       	pop	r12
    1152:	08 95       	ret

00001154 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1154:	cf 93       	push	r28
    1156:	df 93       	push	r29
    1158:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    115a:	89 2b       	or	r24, r25
    115c:	91 f0       	breq	.+36     	; 0x1182 <vTaskDelay+0x2e>
		{
			vTaskSuspendAll();
    115e:	b2 de       	rcall	.-668    	; 0xec4 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1160:	80 91 9e 07 	lds	r24, 0x079E	; 0x80079e <xTickCount>
    1164:	90 91 9f 07 	lds	r25, 0x079F	; 0x80079f <xTickCount+0x1>
    1168:	c8 0f       	add	r28, r24
    116a:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    116c:	80 91 ee 07 	lds	r24, 0x07EE	; 0x8007ee <pxCurrentTCB>
    1170:	90 91 ef 07 	lds	r25, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
    1174:	02 96       	adiw	r24, 0x02	; 2
    1176:	42 d8       	rcall	.-3964   	; 0x1fc <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1178:	ce 01       	movw	r24, r28
    117a:	53 dd       	rcall	.-1370   	; 0xc22 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    117c:	6a df       	rcall	.-300    	; 0x1052 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    117e:	81 11       	cpse	r24, r1
    1180:	01 c0       	rjmp	.+2      	; 0x1184 <vTaskDelay+0x30>
		{
			portYIELD_WITHIN_API();
    1182:	9c dc       	rcall	.-1736   	; 0xabc <vPortYield>
		}
	}
    1184:	df 91       	pop	r29
    1186:	cf 91       	pop	r28
    1188:	08 95       	ret

0000118a <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    118a:	0f 2e       	mov	r0, r31
    118c:	f2 ea       	ldi	r31, 0xA2	; 162
    118e:	ef 2e       	mov	r14, r31
    1190:	f7 e0       	ldi	r31, 0x07	; 7
    1192:	ff 2e       	mov	r15, r31
    1194:	f0 2d       	mov	r31, r0

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    1196:	ca ec       	ldi	r28, 0xCA	; 202
    1198:	d7 e0       	ldi	r29, 0x07	; 7
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    119a:	80 91 a1 07 	lds	r24, 0x07A1	; 0x8007a1 <uxTasksDeleted>
    119e:	88 23       	and	r24, r24
    11a0:	39 f1       	breq	.+78     	; 0x11f0 <prvIdleTask+0x66>
		{
			vTaskSuspendAll();
    11a2:	90 de       	rcall	.-736    	; 0xec4 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    11a4:	d7 01       	movw	r26, r14
    11a6:	1c 91       	ld	r17, X
			xTaskResumeAll();
    11a8:	54 df       	rcall	.-344    	; 0x1052 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    11aa:	11 23       	and	r17, r17
    11ac:	09 f1       	breq	.+66     	; 0x11f0 <prvIdleTask+0x66>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    11ae:	0f b6       	in	r0, 0x3f	; 63
    11b0:	f8 94       	cli
    11b2:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    11b4:	d7 01       	movw	r26, r14
    11b6:	15 96       	adiw	r26, 0x05	; 5
    11b8:	ed 91       	ld	r30, X+
    11ba:	fc 91       	ld	r31, X
    11bc:	16 97       	sbiw	r26, 0x06	; 6
    11be:	06 81       	ldd	r16, Z+6	; 0x06
    11c0:	17 81       	ldd	r17, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    11c2:	c8 01       	movw	r24, r16
    11c4:	02 96       	adiw	r24, 0x02	; 2
    11c6:	1a d8       	rcall	.-4044   	; 0x1fc <vListRemove>
					--uxCurrentNumberOfTasks;
    11c8:	80 91 a0 07 	lds	r24, 0x07A0	; 0x8007a0 <uxCurrentNumberOfTasks>
    11cc:	81 50       	subi	r24, 0x01	; 1
    11ce:	80 93 a0 07 	sts	0x07A0, r24	; 0x8007a0 <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
    11d2:	80 91 a1 07 	lds	r24, 0x07A1	; 0x8007a1 <uxTasksDeleted>
    11d6:	81 50       	subi	r24, 0x01	; 1
    11d8:	80 93 a1 07 	sts	0x07A1, r24	; 0x8007a1 <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
    11dc:	0f 90       	pop	r0
    11de:	0f be       	out	0x3f, r0	; 63
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    11e0:	f8 01       	movw	r30, r16
    11e2:	87 89       	ldd	r24, Z+23	; 0x17
    11e4:	90 8d       	ldd	r25, Z+24	; 0x18
    11e6:	0e 94 89 00 	call	0x112	; 0x112 <vPortFree>
		vPortFree( pxTCB );
    11ea:	c8 01       	movw	r24, r16
    11ec:	0e 94 89 00 	call	0x112	; 0x112 <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    11f0:	88 81       	ld	r24, Y
    11f2:	82 30       	cpi	r24, 0x02	; 2
    11f4:	90 f2       	brcs	.-92     	; 0x119a <prvIdleTask+0x10>
			{
				taskYIELD();
    11f6:	62 dc       	rcall	.-1852   	; 0xabc <vPortYield>
    11f8:	d0 cf       	rjmp	.-96     	; 0x119a <prvIdleTask+0x10>

000011fa <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    11fa:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <uxSchedulerSuspended>
    11fe:	81 11       	cpse	r24, r1
    1200:	13 c0       	rjmp	.+38     	; 0x1228 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1202:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxTopReadyPriority>
    1206:	90 e0       	ldi	r25, 0x00	; 0
    1208:	fc 01       	movw	r30, r24
    120a:	ee 0f       	add	r30, r30
    120c:	ff 1f       	adc	r31, r31
    120e:	ee 0f       	add	r30, r30
    1210:	ff 1f       	adc	r31, r31
    1212:	ee 0f       	add	r30, r30
    1214:	ff 1f       	adc	r31, r31
    1216:	8e 0f       	add	r24, r30
    1218:	9f 1f       	adc	r25, r31
    121a:	fc 01       	movw	r30, r24
    121c:	e6 53       	subi	r30, 0x36	; 54
    121e:	f8 4f       	sbci	r31, 0xF8	; 248
    1220:	80 81       	ld	r24, Z
    1222:	88 23       	and	r24, r24
    1224:	29 f0       	breq	.+10     	; 0x1230 <vTaskSwitchContext+0x36>
    1226:	1b c0       	rjmp	.+54     	; 0x125e <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1228:	81 e0       	ldi	r24, 0x01	; 1
    122a:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <xMissedYield>
    122e:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1230:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxTopReadyPriority>
    1234:	81 50       	subi	r24, 0x01	; 1
    1236:	80 93 9c 07 	sts	0x079C, r24	; 0x80079c <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    123a:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxTopReadyPriority>
    123e:	90 e0       	ldi	r25, 0x00	; 0
    1240:	fc 01       	movw	r30, r24
    1242:	ee 0f       	add	r30, r30
    1244:	ff 1f       	adc	r31, r31
    1246:	ee 0f       	add	r30, r30
    1248:	ff 1f       	adc	r31, r31
    124a:	ee 0f       	add	r30, r30
    124c:	ff 1f       	adc	r31, r31
    124e:	8e 0f       	add	r24, r30
    1250:	9f 1f       	adc	r25, r31
    1252:	fc 01       	movw	r30, r24
    1254:	e6 53       	subi	r30, 0x36	; 54
    1256:	f8 4f       	sbci	r31, 0xF8	; 248
    1258:	80 81       	ld	r24, Z
    125a:	88 23       	and	r24, r24
    125c:	49 f3       	breq	.-46     	; 0x1230 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    125e:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxTopReadyPriority>
    1262:	90 e0       	ldi	r25, 0x00	; 0
    1264:	9c 01       	movw	r18, r24
    1266:	22 0f       	add	r18, r18
    1268:	33 1f       	adc	r19, r19
    126a:	22 0f       	add	r18, r18
    126c:	33 1f       	adc	r19, r19
    126e:	22 0f       	add	r18, r18
    1270:	33 1f       	adc	r19, r19
    1272:	28 0f       	add	r18, r24
    1274:	39 1f       	adc	r19, r25
    1276:	d9 01       	movw	r26, r18
    1278:	a6 53       	subi	r26, 0x36	; 54
    127a:	b8 4f       	sbci	r27, 0xF8	; 248
    127c:	11 96       	adiw	r26, 0x01	; 1
    127e:	ed 91       	ld	r30, X+
    1280:	fc 91       	ld	r31, X
    1282:	12 97       	sbiw	r26, 0x02	; 2
    1284:	02 80       	ldd	r0, Z+2	; 0x02
    1286:	f3 81       	ldd	r31, Z+3	; 0x03
    1288:	e0 2d       	mov	r30, r0
    128a:	12 96       	adiw	r26, 0x02	; 2
    128c:	fc 93       	st	X, r31
    128e:	ee 93       	st	-X, r30
    1290:	11 97       	sbiw	r26, 0x01	; 1
    1292:	23 53       	subi	r18, 0x33	; 51
    1294:	38 4f       	sbci	r19, 0xF8	; 248
    1296:	e2 17       	cp	r30, r18
    1298:	f3 07       	cpc	r31, r19
    129a:	29 f4       	brne	.+10     	; 0x12a6 <vTaskSwitchContext+0xac>
    129c:	22 81       	ldd	r18, Z+2	; 0x02
    129e:	33 81       	ldd	r19, Z+3	; 0x03
    12a0:	fd 01       	movw	r30, r26
    12a2:	32 83       	std	Z+2, r19	; 0x02
    12a4:	21 83       	std	Z+1, r18	; 0x01
    12a6:	fc 01       	movw	r30, r24
    12a8:	ee 0f       	add	r30, r30
    12aa:	ff 1f       	adc	r31, r31
    12ac:	ee 0f       	add	r30, r30
    12ae:	ff 1f       	adc	r31, r31
    12b0:	ee 0f       	add	r30, r30
    12b2:	ff 1f       	adc	r31, r31
    12b4:	8e 0f       	add	r24, r30
    12b6:	9f 1f       	adc	r25, r31
    12b8:	fc 01       	movw	r30, r24
    12ba:	e6 53       	subi	r30, 0x36	; 54
    12bc:	f8 4f       	sbci	r31, 0xF8	; 248
    12be:	01 80       	ldd	r0, Z+1	; 0x01
    12c0:	f2 81       	ldd	r31, Z+2	; 0x02
    12c2:	e0 2d       	mov	r30, r0
    12c4:	86 81       	ldd	r24, Z+6	; 0x06
    12c6:	97 81       	ldd	r25, Z+7	; 0x07
    12c8:	90 93 ef 07 	sts	0x07EF, r25	; 0x8007ef <pxCurrentTCB+0x1>
    12cc:	80 93 ee 07 	sts	0x07EE, r24	; 0x8007ee <pxCurrentTCB>
    12d0:	08 95       	ret

000012d2 <__udivmodqi4>:
    12d2:	99 1b       	sub	r25, r25
    12d4:	79 e0       	ldi	r23, 0x09	; 9
    12d6:	04 c0       	rjmp	.+8      	; 0x12e0 <__udivmodqi4_ep>

000012d8 <__udivmodqi4_loop>:
    12d8:	99 1f       	adc	r25, r25
    12da:	96 17       	cp	r25, r22
    12dc:	08 f0       	brcs	.+2      	; 0x12e0 <__udivmodqi4_ep>
    12de:	96 1b       	sub	r25, r22

000012e0 <__udivmodqi4_ep>:
    12e0:	88 1f       	adc	r24, r24
    12e2:	7a 95       	dec	r23
    12e4:	c9 f7       	brne	.-14     	; 0x12d8 <__udivmodqi4_loop>
    12e6:	80 95       	com	r24
    12e8:	08 95       	ret

000012ea <memset>:
    12ea:	dc 01       	movw	r26, r24
    12ec:	01 c0       	rjmp	.+2      	; 0x12f0 <memset+0x6>
    12ee:	6d 93       	st	X+, r22
    12f0:	41 50       	subi	r20, 0x01	; 1
    12f2:	50 40       	sbci	r21, 0x00	; 0
    12f4:	e0 f7       	brcc	.-8      	; 0x12ee <memset+0x4>
    12f6:	08 95       	ret

000012f8 <strncpy>:
    12f8:	fb 01       	movw	r30, r22
    12fa:	dc 01       	movw	r26, r24
    12fc:	41 50       	subi	r20, 0x01	; 1
    12fe:	50 40       	sbci	r21, 0x00	; 0
    1300:	48 f0       	brcs	.+18     	; 0x1314 <strncpy+0x1c>
    1302:	01 90       	ld	r0, Z+
    1304:	0d 92       	st	X+, r0
    1306:	00 20       	and	r0, r0
    1308:	c9 f7       	brne	.-14     	; 0x12fc <strncpy+0x4>
    130a:	01 c0       	rjmp	.+2      	; 0x130e <strncpy+0x16>
    130c:	1d 92       	st	X+, r1
    130e:	41 50       	subi	r20, 0x01	; 1
    1310:	50 40       	sbci	r21, 0x00	; 0
    1312:	e0 f7       	brcc	.-8      	; 0x130c <strncpy+0x14>
    1314:	08 95       	ret

00001316 <_exit>:
    1316:	f8 94       	cli

00001318 <__stop_program>:
    1318:	ff cf       	rjmp	.-2      	; 0x1318 <__stop_program>
