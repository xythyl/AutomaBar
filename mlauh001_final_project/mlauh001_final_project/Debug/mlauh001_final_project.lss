
mlauh001_final_project.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000a2  00800100  0000132a  000013be  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000132a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000654  008001a2  008001a2  00001460  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001460  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001490  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000260  00000000  00000000  000014d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002560  00000000  00000000  00001730  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000009ab  00000000  00000000  00003c90  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001879  00000000  00000000  0000463b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000005dc  00000000  00000000  00005eb4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000eb0  00000000  00000000  00006490  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000015a9  00000000  00000000  00007340  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000258  00000000  00000000  000088e9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
       2:	00 00       	nop
       4:	61 c0       	rjmp	.+194    	; 0xc8 <__bad_interrupt>
       6:	00 00       	nop
       8:	5f c0       	rjmp	.+190    	; 0xc8 <__bad_interrupt>
       a:	00 00       	nop
       c:	5d c0       	rjmp	.+186    	; 0xc8 <__bad_interrupt>
       e:	00 00       	nop
      10:	5b c0       	rjmp	.+182    	; 0xc8 <__bad_interrupt>
      12:	00 00       	nop
      14:	59 c0       	rjmp	.+178    	; 0xc8 <__bad_interrupt>
      16:	00 00       	nop
      18:	57 c0       	rjmp	.+174    	; 0xc8 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	55 c0       	rjmp	.+170    	; 0xc8 <__bad_interrupt>
      1e:	00 00       	nop
      20:	53 c0       	rjmp	.+166    	; 0xc8 <__bad_interrupt>
      22:	00 00       	nop
      24:	51 c0       	rjmp	.+162    	; 0xc8 <__bad_interrupt>
      26:	00 00       	nop
      28:	4f c0       	rjmp	.+158    	; 0xc8 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	4d c0       	rjmp	.+154    	; 0xc8 <__bad_interrupt>
      2e:	00 00       	nop
      30:	4b c0       	rjmp	.+150    	; 0xc8 <__bad_interrupt>
      32:	00 00       	nop
      34:	fc c5       	rjmp	.+3064   	; 0xc2e <__vector_13>
      36:	00 00       	nop
      38:	47 c0       	rjmp	.+142    	; 0xc8 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	45 c0       	rjmp	.+138    	; 0xc8 <__bad_interrupt>
      3e:	00 00       	nop
      40:	43 c0       	rjmp	.+134    	; 0xc8 <__bad_interrupt>
      42:	00 00       	nop
      44:	41 c0       	rjmp	.+130    	; 0xc8 <__bad_interrupt>
      46:	00 00       	nop
      48:	3f c0       	rjmp	.+126    	; 0xc8 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	3d c0       	rjmp	.+122    	; 0xc8 <__bad_interrupt>
      4e:	00 00       	nop
      50:	3b c0       	rjmp	.+118    	; 0xc8 <__bad_interrupt>
      52:	00 00       	nop
      54:	39 c0       	rjmp	.+114    	; 0xc8 <__bad_interrupt>
      56:	00 00       	nop
      58:	37 c0       	rjmp	.+110    	; 0xc8 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	35 c0       	rjmp	.+106    	; 0xc8 <__bad_interrupt>
      5e:	00 00       	nop
      60:	33 c0       	rjmp	.+102    	; 0xc8 <__bad_interrupt>
      62:	00 00       	nop
      64:	31 c0       	rjmp	.+98     	; 0xc8 <__bad_interrupt>
      66:	00 00       	nop
      68:	2f c0       	rjmp	.+94     	; 0xc8 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	2d c0       	rjmp	.+90     	; 0xc8 <__bad_interrupt>
      6e:	00 00       	nop
      70:	2b c0       	rjmp	.+86     	; 0xc8 <__bad_interrupt>
      72:	00 00       	nop
      74:	29 c0       	rjmp	.+82     	; 0xc8 <__bad_interrupt>
      76:	00 00       	nop
      78:	27 c0       	rjmp	.+78     	; 0xc8 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	25 c0       	rjmp	.+74     	; 0xc8 <__bad_interrupt>
      7e:	00 00       	nop
      80:	23 c0       	rjmp	.+70     	; 0xc8 <__bad_interrupt>
      82:	00 00       	nop
      84:	21 c0       	rjmp	.+66     	; 0xc8 <__bad_interrupt>
      86:	00 00       	nop
      88:	1f c0       	rjmp	.+62     	; 0xc8 <__bad_interrupt>
	...

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e4       	ldi	r29, 0x40	; 64
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	ea e2       	ldi	r30, 0x2A	; 42
      a0:	f3 e1       	ldi	r31, 0x13	; 19
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	a2 3a       	cpi	r26, 0xA2	; 162
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	27 e0       	ldi	r18, 0x07	; 7
      b4:	a2 ea       	ldi	r26, 0xA2	; 162
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	a6 3f       	cpi	r26, 0xF6	; 246
      be:	b2 07       	cpc	r27, r18
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	4d d4       	rcall	.+2202   	; 0x95e <main>
      c4:	0c 94 93 09 	jmp	0x1326	; 0x1326 <_exit>

000000c8 <__bad_interrupt>:
      c8:	9b cf       	rjmp	.-202    	; 0x0 <__vectors>

000000ca <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
      ca:	cf 93       	push	r28
      cc:	df 93       	push	r29
      ce:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
      d0:	01 d7       	rcall	.+3586   	; 0xed4 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
      d2:	20 91 a2 01 	lds	r18, 0x01A2	; 0x8001a2 <__data_end>
      d6:	30 91 a3 01 	lds	r19, 0x01A3	; 0x8001a3 <__data_end+0x1>
      da:	ce 01       	movw	r24, r28
      dc:	82 0f       	add	r24, r18
      de:	93 1f       	adc	r25, r19
      e0:	8c 3d       	cpi	r24, 0xDC	; 220
      e2:	45 e0       	ldi	r20, 0x05	; 5
      e4:	94 07       	cpc	r25, r20
      e6:	58 f4       	brcc	.+22     	; 0xfe <pvPortMalloc+0x34>
      e8:	28 17       	cp	r18, r24
      ea:	39 07       	cpc	r19, r25
      ec:	58 f4       	brcc	.+22     	; 0x104 <pvPortMalloc+0x3a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
      ee:	e9 01       	movw	r28, r18
      f0:	cc 55       	subi	r28, 0x5C	; 92
      f2:	de 4f       	sbci	r29, 0xFE	; 254
			xNextFreeByte += xWantedSize;			
      f4:	90 93 a3 01 	sts	0x01A3, r25	; 0x8001a3 <__data_end+0x1>
      f8:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <__data_end>
      fc:	05 c0       	rjmp	.+10     	; 0x108 <pvPortMalloc+0x3e>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
      fe:	c0 e0       	ldi	r28, 0x00	; 0
     100:	d0 e0       	ldi	r29, 0x00	; 0
     102:	02 c0       	rjmp	.+4      	; 0x108 <pvPortMalloc+0x3e>
     104:	c0 e0       	ldi	r28, 0x00	; 0
     106:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     108:	ac d7       	rcall	.+3928   	; 0x1062 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
     10a:	ce 01       	movw	r24, r28
     10c:	df 91       	pop	r29
     10e:	cf 91       	pop	r28
     110:	08 95       	ret

00000112 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     112:	08 95       	ret

00000114 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     114:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     116:	03 96       	adiw	r24, 0x03	; 3
     118:	92 83       	std	Z+2, r25	; 0x02
     11a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     11c:	2f ef       	ldi	r18, 0xFF	; 255
     11e:	3f ef       	ldi	r19, 0xFF	; 255
     120:	34 83       	std	Z+4, r19	; 0x04
     122:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     124:	96 83       	std	Z+6, r25	; 0x06
     126:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     128:	90 87       	std	Z+8, r25	; 0x08
     12a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     12c:	10 82       	st	Z, r1
     12e:	08 95       	ret

00000130 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     130:	fc 01       	movw	r30, r24
     132:	11 86       	std	Z+9, r1	; 0x09
     134:	10 86       	std	Z+8, r1	; 0x08
     136:	08 95       	ret

00000138 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     138:	cf 93       	push	r28
     13a:	df 93       	push	r29
     13c:	fc 01       	movw	r30, r24
     13e:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     140:	21 81       	ldd	r18, Z+1	; 0x01
     142:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     144:	e9 01       	movw	r28, r18
     146:	8a 81       	ldd	r24, Y+2	; 0x02
     148:	9b 81       	ldd	r25, Y+3	; 0x03
     14a:	13 96       	adiw	r26, 0x03	; 3
     14c:	9c 93       	st	X, r25
     14e:	8e 93       	st	-X, r24
     150:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     152:	81 81       	ldd	r24, Z+1	; 0x01
     154:	92 81       	ldd	r25, Z+2	; 0x02
     156:	15 96       	adiw	r26, 0x05	; 5
     158:	9c 93       	st	X, r25
     15a:	8e 93       	st	-X, r24
     15c:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     15e:	8a 81       	ldd	r24, Y+2	; 0x02
     160:	9b 81       	ldd	r25, Y+3	; 0x03
     162:	ec 01       	movw	r28, r24
     164:	7d 83       	std	Y+5, r23	; 0x05
     166:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     168:	e9 01       	movw	r28, r18
     16a:	7b 83       	std	Y+3, r23	; 0x03
     16c:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     16e:	72 83       	std	Z+2, r23	; 0x02
     170:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     172:	19 96       	adiw	r26, 0x09	; 9
     174:	fc 93       	st	X, r31
     176:	ee 93       	st	-X, r30
     178:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     17a:	80 81       	ld	r24, Z
     17c:	8f 5f       	subi	r24, 0xFF	; 255
     17e:	80 83       	st	Z, r24
}
     180:	df 91       	pop	r29
     182:	cf 91       	pop	r28
     184:	08 95       	ret

00000186 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     186:	cf 93       	push	r28
     188:	df 93       	push	r29
     18a:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     18c:	48 81       	ld	r20, Y
     18e:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     190:	4f 3f       	cpi	r20, 0xFF	; 255
     192:	2f ef       	ldi	r18, 0xFF	; 255
     194:	52 07       	cpc	r21, r18
     196:	31 f4       	brne	.+12     	; 0x1a4 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     198:	dc 01       	movw	r26, r24
     19a:	17 96       	adiw	r26, 0x07	; 7
     19c:	ed 91       	ld	r30, X+
     19e:	fc 91       	ld	r31, X
     1a0:	18 97       	sbiw	r26, 0x08	; 8
     1a2:	17 c0       	rjmp	.+46     	; 0x1d2 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     1a4:	fc 01       	movw	r30, r24
     1a6:	33 96       	adiw	r30, 0x03	; 3
     1a8:	dc 01       	movw	r26, r24
     1aa:	15 96       	adiw	r26, 0x05	; 5
     1ac:	2d 91       	ld	r18, X+
     1ae:	3c 91       	ld	r19, X
     1b0:	16 97       	sbiw	r26, 0x06	; 6
     1b2:	d9 01       	movw	r26, r18
     1b4:	2d 91       	ld	r18, X+
     1b6:	3c 91       	ld	r19, X
     1b8:	42 17       	cp	r20, r18
     1ba:	53 07       	cpc	r21, r19
     1bc:	50 f0       	brcs	.+20     	; 0x1d2 <vListInsert+0x4c>
     1be:	02 80       	ldd	r0, Z+2	; 0x02
     1c0:	f3 81       	ldd	r31, Z+3	; 0x03
     1c2:	e0 2d       	mov	r30, r0
     1c4:	a2 81       	ldd	r26, Z+2	; 0x02
     1c6:	b3 81       	ldd	r27, Z+3	; 0x03
     1c8:	2d 91       	ld	r18, X+
     1ca:	3c 91       	ld	r19, X
     1cc:	42 17       	cp	r20, r18
     1ce:	53 07       	cpc	r21, r19
     1d0:	b0 f7       	brcc	.-20     	; 0x1be <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     1d2:	a2 81       	ldd	r26, Z+2	; 0x02
     1d4:	b3 81       	ldd	r27, Z+3	; 0x03
     1d6:	bb 83       	std	Y+3, r27	; 0x03
     1d8:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     1da:	15 96       	adiw	r26, 0x05	; 5
     1dc:	dc 93       	st	X, r29
     1de:	ce 93       	st	-X, r28
     1e0:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     1e2:	fd 83       	std	Y+5, r31	; 0x05
     1e4:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     1e6:	d3 83       	std	Z+3, r29	; 0x03
     1e8:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     1ea:	99 87       	std	Y+9, r25	; 0x09
     1ec:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     1ee:	fc 01       	movw	r30, r24
     1f0:	20 81       	ld	r18, Z
     1f2:	2f 5f       	subi	r18, 0xFF	; 255
     1f4:	20 83       	st	Z, r18
}
     1f6:	df 91       	pop	r29
     1f8:	cf 91       	pop	r28
     1fa:	08 95       	ret

000001fc <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     1fc:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     1fe:	a2 81       	ldd	r26, Z+2	; 0x02
     200:	b3 81       	ldd	r27, Z+3	; 0x03
     202:	84 81       	ldd	r24, Z+4	; 0x04
     204:	95 81       	ldd	r25, Z+5	; 0x05
     206:	15 96       	adiw	r26, 0x05	; 5
     208:	9c 93       	st	X, r25
     20a:	8e 93       	st	-X, r24
     20c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     20e:	a4 81       	ldd	r26, Z+4	; 0x04
     210:	b5 81       	ldd	r27, Z+5	; 0x05
     212:	82 81       	ldd	r24, Z+2	; 0x02
     214:	93 81       	ldd	r25, Z+3	; 0x03
     216:	13 96       	adiw	r26, 0x03	; 3
     218:	9c 93       	st	X, r25
     21a:	8e 93       	st	-X, r24
     21c:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     21e:	a0 85       	ldd	r26, Z+8	; 0x08
     220:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     222:	11 96       	adiw	r26, 0x01	; 1
     224:	8d 91       	ld	r24, X+
     226:	9c 91       	ld	r25, X
     228:	12 97       	sbiw	r26, 0x02	; 2
     22a:	8e 17       	cp	r24, r30
     22c:	9f 07       	cpc	r25, r31
     22e:	31 f4       	brne	.+12     	; 0x23c <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     230:	84 81       	ldd	r24, Z+4	; 0x04
     232:	95 81       	ldd	r25, Z+5	; 0x05
     234:	12 96       	adiw	r26, 0x02	; 2
     236:	9c 93       	st	X, r25
     238:	8e 93       	st	-X, r24
     23a:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     23c:	11 86       	std	Z+9, r1	; 0x09
     23e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     240:	8c 91       	ld	r24, X
     242:	81 50       	subi	r24, 0x01	; 1
     244:	8c 93       	st	X, r24
     246:	08 95       	ret

00000248 <initUSART>:
void PollUSART_Init() {
	poll_usart_state = PollUSART_INIT;
}

void MakeDrink_Init() {
	make_drink_state = MakeDrink_INIT;
     248:	81 30       	cpi	r24, 0x01	; 1
     24a:	81 f0       	breq	.+32     	; 0x26c <initUSART+0x24>
     24c:	e1 ec       	ldi	r30, 0xC1	; 193
     24e:	f0 e0       	ldi	r31, 0x00	; 0
     250:	80 81       	ld	r24, Z
     252:	88 61       	ori	r24, 0x18	; 24
     254:	80 83       	st	Z, r24
     256:	e2 ec       	ldi	r30, 0xC2	; 194
     258:	f0 e0       	ldi	r31, 0x00	; 0
     25a:	80 81       	ld	r24, Z
     25c:	86 60       	ori	r24, 0x06	; 6
     25e:	80 83       	st	Z, r24
     260:	83 e3       	ldi	r24, 0x33	; 51
     262:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
     266:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
     26a:	08 95       	ret
     26c:	e9 ec       	ldi	r30, 0xC9	; 201
     26e:	f0 e0       	ldi	r31, 0x00	; 0
     270:	80 81       	ld	r24, Z
     272:	88 61       	ori	r24, 0x18	; 24
     274:	80 83       	st	Z, r24
     276:	ea ec       	ldi	r30, 0xCA	; 202
     278:	f0 e0       	ldi	r31, 0x00	; 0
     27a:	80 81       	ld	r24, Z
     27c:	86 60       	ori	r24, 0x06	; 6
     27e:	80 83       	st	Z, r24
     280:	83 e3       	ldi	r24, 0x33	; 51
     282:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7e00cc>
     286:	10 92 cd 00 	sts	0x00CD, r1	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7e00cd>
     28a:	08 95       	ret

0000028c <USART_Flush>:
     28c:	81 30       	cpi	r24, 0x01	; 1
     28e:	29 f4       	brne	.+10     	; 0x29a <USART_Flush+0xe>
     290:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7e00c8>
     294:	88 23       	and	r24, r24
     296:	84 f0       	brlt	.+32     	; 0x2b8 <USART_Flush+0x2c>
     298:	08 95       	ret
     29a:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     29e:	88 23       	and	r24, r24
     2a0:	ac f4       	brge	.+42     	; 0x2cc <USART_Flush+0x40>
     2a2:	a6 ec       	ldi	r26, 0xC6	; 198
     2a4:	b0 e0       	ldi	r27, 0x00	; 0
     2a6:	e0 ec       	ldi	r30, 0xC0	; 192
     2a8:	f0 e0       	ldi	r31, 0x00	; 0
     2aa:	8c 91       	ld	r24, X
     2ac:	80 93 80 07 	sts	0x0780, r24	; 0x800780 <dummy.2320>
     2b0:	80 81       	ld	r24, Z
     2b2:	88 23       	and	r24, r24
     2b4:	d4 f3       	brlt	.-12     	; 0x2aa <USART_Flush+0x1e>
     2b6:	08 95       	ret
     2b8:	ae ec       	ldi	r26, 0xCE	; 206
     2ba:	b0 e0       	ldi	r27, 0x00	; 0
     2bc:	e8 ec       	ldi	r30, 0xC8	; 200
     2be:	f0 e0       	ldi	r31, 0x00	; 0
     2c0:	8c 91       	ld	r24, X
     2c2:	80 93 80 07 	sts	0x0780, r24	; 0x800780 <dummy.2320>
     2c6:	80 81       	ld	r24, Z
     2c8:	88 23       	and	r24, r24
     2ca:	d4 f3       	brlt	.-12     	; 0x2c0 <USART_Flush+0x34>
     2cc:	08 95       	ret

000002ce <USART_Send>:
     2ce:	61 30       	cpi	r22, 0x01	; 1
     2d0:	41 f0       	breq	.+16     	; 0x2e2 <USART_Send+0x14>
     2d2:	e0 ec       	ldi	r30, 0xC0	; 192
     2d4:	f0 e0       	ldi	r31, 0x00	; 0
     2d6:	90 81       	ld	r25, Z
     2d8:	95 ff       	sbrs	r25, 5
     2da:	fd cf       	rjmp	.-6      	; 0x2d6 <USART_Send+0x8>
     2dc:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     2e0:	08 95       	ret
     2e2:	e8 ec       	ldi	r30, 0xC8	; 200
     2e4:	f0 e0       	ldi	r31, 0x00	; 0
     2e6:	90 81       	ld	r25, Z
     2e8:	95 ff       	sbrs	r25, 5
     2ea:	fd cf       	rjmp	.-6      	; 0x2e6 <USART_Send+0x18>
     2ec:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
     2f0:	08 95       	ret

000002f2 <USART_Receive>:
     2f2:	81 30       	cpi	r24, 0x01	; 1
     2f4:	41 f0       	breq	.+16     	; 0x306 <USART_Receive+0x14>
     2f6:	e0 ec       	ldi	r30, 0xC0	; 192
     2f8:	f0 e0       	ldi	r31, 0x00	; 0
     2fa:	80 81       	ld	r24, Z
     2fc:	88 23       	and	r24, r24
     2fe:	ec f7       	brge	.-6      	; 0x2fa <USART_Receive+0x8>
     300:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     304:	08 95       	ret
     306:	e8 ec       	ldi	r30, 0xC8	; 200
     308:	f0 e0       	ldi	r31, 0x00	; 0
     30a:	80 81       	ld	r24, Z
     30c:	88 23       	and	r24, r24
     30e:	ec f7       	brge	.-6      	; 0x30a <USART_Receive+0x18>
     310:	80 91 ce 00 	lds	r24, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
     314:	08 95       	ret

00000316 <USART_Send_String>:
     316:	ff 92       	push	r15
     318:	0f 93       	push	r16
     31a:	1f 93       	push	r17
     31c:	cf 93       	push	r28
     31e:	df 93       	push	r29
     320:	06 2f       	mov	r16, r22
     322:	fc 01       	movw	r30, r24
     324:	01 90       	ld	r0, Z+
     326:	00 20       	and	r0, r0
     328:	e9 f7       	brne	.-6      	; 0x324 <USART_Send_String+0xe>
     32a:	31 97       	sbiw	r30, 0x01	; 1
     32c:	1e 2f       	mov	r17, r30
     32e:	18 1b       	sub	r17, r24
     330:	51 f0       	breq	.+20     	; 0x346 <USART_Send_String+0x30>
     332:	f8 2e       	mov	r15, r24
     334:	c8 2f       	mov	r28, r24
     336:	d9 2f       	mov	r29, r25
     338:	60 2f       	mov	r22, r16
     33a:	89 91       	ld	r24, Y+
     33c:	c8 df       	rcall	.-112    	; 0x2ce <USART_Send>
     33e:	8c 2f       	mov	r24, r28
     340:	8f 19       	sub	r24, r15
     342:	81 17       	cp	r24, r17
     344:	c8 f3       	brcs	.-14     	; 0x338 <USART_Send_String+0x22>
     346:	60 2f       	mov	r22, r16
     348:	8f ef       	ldi	r24, 0xFF	; 255
     34a:	c1 df       	rcall	.-126    	; 0x2ce <USART_Send>
     34c:	60 2f       	mov	r22, r16
     34e:	8f ef       	ldi	r24, 0xFF	; 255
     350:	be df       	rcall	.-132    	; 0x2ce <USART_Send>
     352:	60 2f       	mov	r22, r16
     354:	8f ef       	ldi	r24, 0xFF	; 255
     356:	bb df       	rcall	.-138    	; 0x2ce <USART_Send>
     358:	df 91       	pop	r29
     35a:	cf 91       	pop	r28
     35c:	1f 91       	pop	r17
     35e:	0f 91       	pop	r16
     360:	ff 90       	pop	r15
     362:	08 95       	ret

00000364 <Rotate_Tick>:
}

void Rotate_Tick(){
	//USART_Send_String("page page1",0);
	//Actions
	switch(rotate_state){
     364:	80 91 f1 07 	lds	r24, 0x07F1	; 0x8007f1 <rotate_state>
     368:	81 30       	cpi	r24, 0x01	; 1
     36a:	49 f0       	breq	.+18     	; 0x37e <Rotate_Tick+0x1a>
     36c:	18 f0       	brcs	.+6      	; 0x374 <Rotate_Tick+0x10>
     36e:	82 30       	cpi	r24, 0x02	; 2
     370:	91 f0       	breq	.+36     	; 0x396 <Rotate_Tick+0x32>
     372:	4c c0       	rjmp	.+152    	; 0x40c <__FUSE_REGION_LENGTH__+0xc>
		case Rotate_INIT:
			//PORTA = 0;
			rotate_stepper = 0;
     374:	10 92 8d 07 	sts	0x078D, r1	; 0x80078d <rotate_stepper>
			current_position = 0;
     378:	10 92 92 07 	sts	0x0792, r1	; 0x800792 <current_position>
     37c:	50 c0       	rjmp	.+160    	; 0x41e <__FUSE_REGION_LENGTH__+0x1e>
			break;
		case Rotate_Wait:
			cnt = 0; //index in list of steps
     37e:	10 92 95 07 	sts	0x0795, r1	; 0x800795 <cnt>
			total_cnt = 0; //count of total number of steps
     382:	10 92 94 07 	sts	0x0794, r1	; 0x800794 <total_cnt+0x1>
     386:	10 92 93 07 	sts	0x0793, r1	; 0x800793 <total_cnt>
			//drink = 0; //drink selected
			drink_select = ~PINB & 0x3F;
     38a:	83 b1       	in	r24, 0x03	; 3
     38c:	80 95       	com	r24
     38e:	8f 73       	andi	r24, 0x3F	; 63
     390:	80 93 8e 07 	sts	0x078E, r24	; 0x80078e <drink_select>
     394:	48 c0       	rjmp	.+144    	; 0x426 <__FUSE_REGION_LENGTH__+0x26>
				//USART_Send_String(lcd_str,1);
			}
			*/
			break;
		case go_to_drink:
			if (current_position < drink) {
     396:	90 91 92 07 	lds	r25, 0x0792	; 0x800792 <current_position>
     39a:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <drink>
     39e:	98 17       	cp	r25, r24
     3a0:	c8 f4       	brcc	.+50     	; 0x3d4 <Rotate_Tick+0x70>
					//forward	
					//PORTA = forward_steps[cnt++];
					rotate_stepper = forward_steps[cnt++];
     3a2:	80 91 95 07 	lds	r24, 0x0795	; 0x800795 <cnt>
     3a6:	e8 2f       	mov	r30, r24
     3a8:	f0 e0       	ldi	r31, 0x00	; 0
     3aa:	e2 5d       	subi	r30, 0xD2	; 210
     3ac:	fe 4f       	sbci	r31, 0xFE	; 254
     3ae:	90 81       	ld	r25, Z
     3b0:	90 93 8d 07 	sts	0x078D, r25	; 0x80078d <rotate_stepper>
     3b4:	8f 5f       	subi	r24, 0xFF	; 255
					cnt %= num_steps;
     3b6:	60 91 29 01 	lds	r22, 0x0129	; 0x800129 <num_steps>
     3ba:	93 d7       	rcall	.+3878   	; 0x12e2 <__udivmodqi4>
     3bc:	90 93 95 07 	sts	0x0795, r25	; 0x800795 <cnt>
					total_cnt++;
     3c0:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <total_cnt>
     3c4:	90 91 94 07 	lds	r25, 0x0794	; 0x800794 <total_cnt+0x1>
     3c8:	01 96       	adiw	r24, 0x01	; 1
     3ca:	90 93 94 07 	sts	0x0794, r25	; 0x800794 <total_cnt+0x1>
     3ce:	80 93 93 07 	sts	0x0793, r24	; 0x800793 <total_cnt>
     3d2:	8f c0       	rjmp	.+286    	; 0x4f2 <__FUSE_REGION_LENGTH__+0xf2>
			}	
			else if (current_position > drink) {
     3d4:	89 17       	cp	r24, r25
     3d6:	08 f0       	brcs	.+2      	; 0x3da <Rotate_Tick+0x76>
     3d8:	8c c0       	rjmp	.+280    	; 0x4f2 <__FUSE_REGION_LENGTH__+0xf2>
					//backward
					//PORTA = backward_steps[cnt++];
					rotate_stepper = backward_steps[cnt++];
     3da:	80 91 95 07 	lds	r24, 0x0795	; 0x800795 <cnt>
     3de:	e8 2f       	mov	r30, r24
     3e0:	f0 e0       	ldi	r31, 0x00	; 0
     3e2:	e6 5d       	subi	r30, 0xD6	; 214
     3e4:	fe 4f       	sbci	r31, 0xFE	; 254
     3e6:	90 81       	ld	r25, Z
     3e8:	90 93 8d 07 	sts	0x078D, r25	; 0x80078d <rotate_stepper>
     3ec:	8f 5f       	subi	r24, 0xFF	; 255
					cnt %= num_steps;
     3ee:	60 91 29 01 	lds	r22, 0x0129	; 0x800129 <num_steps>
     3f2:	77 d7       	rcall	.+3822   	; 0x12e2 <__udivmodqi4>
     3f4:	90 93 95 07 	sts	0x0795, r25	; 0x800795 <cnt>
					total_cnt++;
     3f8:	80 91 93 07 	lds	r24, 0x0793	; 0x800793 <total_cnt>
     3fc:	90 91 94 07 	lds	r25, 0x0794	; 0x800794 <total_cnt+0x1>
     400:	01 96       	adiw	r24, 0x01	; 1
     402:	90 93 94 07 	sts	0x0794, r25	; 0x800794 <total_cnt+0x1>
     406:	80 93 93 07 	sts	0x0793, r24	; 0x800793 <total_cnt>
     40a:	73 c0       	rjmp	.+230    	; 0x4f2 <__FUSE_REGION_LENGTH__+0xf2>
			}
			break;
		default:
			//PORTA = 0;
			rotate_stepper = 0;
     40c:	10 92 8d 07 	sts	0x078D, r1	; 0x80078d <rotate_stepper>
			break;
	}

	//Transitions
	//----------------------------
	switch(rotate_state){
     410:	81 30       	cpi	r24, 0x01	; 1
     412:	49 f0       	breq	.+18     	; 0x426 <__FUSE_REGION_LENGTH__+0x26>
     414:	20 f0       	brcs	.+8      	; 0x41e <__FUSE_REGION_LENGTH__+0x1e>
     416:	82 30       	cpi	r24, 0x02	; 2
     418:	09 f0       	breq	.+2      	; 0x41c <__FUSE_REGION_LENGTH__+0x1c>
     41a:	87 c0       	rjmp	.+270    	; 0x52a <__FUSE_REGION_LENGTH__+0x12a>
     41c:	6a c0       	rjmp	.+212    	; 0x4f2 <__FUSE_REGION_LENGTH__+0xf2>
		case Rotate_INIT:
			rotate_state = Rotate_Wait;
     41e:	81 e0       	ldi	r24, 0x01	; 1
     420:	80 93 f1 07 	sts	0x07F1, r24	; 0x8007f1 <rotate_state>
			break;
     424:	08 95       	ret
		case Rotate_Wait:
			if (drink_select) {
     426:	80 91 8e 07 	lds	r24, 0x078E	; 0x80078e <drink_select>
     42a:	88 23       	and	r24, r24
     42c:	e9 f1       	breq	.+122    	; 0x4a8 <__FUSE_REGION_LENGTH__+0xa8>
				if (drink_select == 0x01) { drink = 0;}
     42e:	81 30       	cpi	r24, 0x01	; 1
     430:	19 f4       	brne	.+6      	; 0x438 <__FUSE_REGION_LENGTH__+0x38>
     432:	10 92 8f 07 	sts	0x078F, r1	; 0x80078f <drink>
     436:	1d c0       	rjmp	.+58     	; 0x472 <__FUSE_REGION_LENGTH__+0x72>
				else if (drink_select == 0x02) { drink = 1;}
     438:	82 30       	cpi	r24, 0x02	; 2
     43a:	21 f4       	brne	.+8      	; 0x444 <__FUSE_REGION_LENGTH__+0x44>
     43c:	81 e0       	ldi	r24, 0x01	; 1
     43e:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <drink>
     442:	17 c0       	rjmp	.+46     	; 0x472 <__FUSE_REGION_LENGTH__+0x72>
				else if (drink_select == 0x04) { drink = 2;}
     444:	84 30       	cpi	r24, 0x04	; 4
     446:	21 f4       	brne	.+8      	; 0x450 <__FUSE_REGION_LENGTH__+0x50>
     448:	82 e0       	ldi	r24, 0x02	; 2
     44a:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <drink>
     44e:	11 c0       	rjmp	.+34     	; 0x472 <__FUSE_REGION_LENGTH__+0x72>
				else if (drink_select == 0x08) { drink = 3;}
     450:	88 30       	cpi	r24, 0x08	; 8
     452:	21 f4       	brne	.+8      	; 0x45c <__FUSE_REGION_LENGTH__+0x5c>
     454:	83 e0       	ldi	r24, 0x03	; 3
     456:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <drink>
     45a:	0b c0       	rjmp	.+22     	; 0x472 <__FUSE_REGION_LENGTH__+0x72>
				else if (drink_select == 0x10) { drink = 4;}
     45c:	80 31       	cpi	r24, 0x10	; 16
     45e:	21 f4       	brne	.+8      	; 0x468 <__FUSE_REGION_LENGTH__+0x68>
     460:	84 e0       	ldi	r24, 0x04	; 4
     462:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <drink>
     466:	05 c0       	rjmp	.+10     	; 0x472 <__FUSE_REGION_LENGTH__+0x72>
				else if (drink_select == 0x20) { drink = 5;}
     468:	80 32       	cpi	r24, 0x20	; 32
     46a:	19 f4       	brne	.+6      	; 0x472 <__FUSE_REGION_LENGTH__+0x72>
     46c:	85 e0       	ldi	r24, 0x05	; 5
     46e:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <drink>
				//PORTC = drink;
				steps_next_drink = abs(next_drink * (drink - current_position));
     472:	40 91 28 01 	lds	r20, 0x0128	; 0x800128 <next_drink>
     476:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <drink>
     47a:	90 e0       	ldi	r25, 0x00	; 0
     47c:	20 91 92 07 	lds	r18, 0x0792	; 0x800792 <current_position>
     480:	82 1b       	sub	r24, r18
     482:	91 09       	sbc	r25, r1
     484:	48 9f       	mul	r20, r24
     486:	90 01       	movw	r18, r0
     488:	49 9f       	mul	r20, r25
     48a:	30 0d       	add	r19, r0
     48c:	11 24       	eor	r1, r1
     48e:	33 23       	and	r19, r19
     490:	1c f4       	brge	.+6      	; 0x498 <__FUSE_REGION_LENGTH__+0x98>
     492:	31 95       	neg	r19
     494:	21 95       	neg	r18
     496:	31 09       	sbc	r19, r1
     498:	30 93 91 07 	sts	0x0791, r19	; 0x800791 <steps_next_drink+0x1>
     49c:	20 93 90 07 	sts	0x0790, r18	; 0x800790 <steps_next_drink>
				rotate_state = go_to_drink;
     4a0:	82 e0       	ldi	r24, 0x02	; 2
     4a2:	80 93 f1 07 	sts	0x07F1, r24	; 0x8007f1 <rotate_state>
     4a6:	08 95       	ret
			}
			else if (rotate_flag == 0x01) {
     4a8:	80 91 82 07 	lds	r24, 0x0782	; 0x800782 <rotate_flag>
     4ac:	81 30       	cpi	r24, 0x01	; 1
     4ae:	e9 f4       	brne	.+58     	; 0x4ea <__FUSE_REGION_LENGTH__+0xea>
					steps_next_drink = abs(next_drink * (drink - current_position));
     4b0:	40 91 8f 07 	lds	r20, 0x078F	; 0x80078f <drink>
     4b4:	50 91 28 01 	lds	r21, 0x0128	; 0x800128 <next_drink>
     4b8:	84 2f       	mov	r24, r20
     4ba:	90 e0       	ldi	r25, 0x00	; 0
     4bc:	20 91 92 07 	lds	r18, 0x0792	; 0x800792 <current_position>
     4c0:	82 1b       	sub	r24, r18
     4c2:	91 09       	sbc	r25, r1
     4c4:	58 9f       	mul	r21, r24
     4c6:	90 01       	movw	r18, r0
     4c8:	59 9f       	mul	r21, r25
     4ca:	30 0d       	add	r19, r0
     4cc:	11 24       	eor	r1, r1
     4ce:	33 23       	and	r19, r19
     4d0:	1c f4       	brge	.+6      	; 0x4d8 <__FUSE_REGION_LENGTH__+0xd8>
     4d2:	31 95       	neg	r19
     4d4:	21 95       	neg	r18
     4d6:	31 09       	sbc	r19, r1
     4d8:	30 93 91 07 	sts	0x0791, r19	; 0x800791 <steps_next_drink+0x1>
     4dc:	20 93 90 07 	sts	0x0790, r18	; 0x800790 <steps_next_drink>
					rotate_state = go_to_drink;
     4e0:	82 e0       	ldi	r24, 0x02	; 2
     4e2:	80 93 f1 07 	sts	0x07F1, r24	; 0x8007f1 <rotate_state>
					PORTC = drink;
     4e6:	48 b9       	out	0x08, r20	; 8
     4e8:	08 95       	ret
					//USART_Send(drink+1,1);
			}
			else {
				rotate_state = Rotate_Wait;
     4ea:	81 e0       	ldi	r24, 0x01	; 1
     4ec:	80 93 f1 07 	sts	0x07F1, r24	; 0x8007f1 <rotate_state>
     4f0:	08 95       	ret
			}
			break;
		case go_to_drink:
			if (total_cnt < steps_next_drink) {
     4f2:	20 91 93 07 	lds	r18, 0x0793	; 0x800793 <total_cnt>
     4f6:	30 91 94 07 	lds	r19, 0x0794	; 0x800794 <total_cnt+0x1>
     4fa:	80 91 90 07 	lds	r24, 0x0790	; 0x800790 <steps_next_drink>
     4fe:	90 91 91 07 	lds	r25, 0x0791	; 0x800791 <steps_next_drink+0x1>
     502:	28 17       	cp	r18, r24
     504:	39 07       	cpc	r19, r25
     506:	20 f4       	brcc	.+8      	; 0x510 <__FUSE_REGION_LENGTH__+0x110>
				rotate_state = go_to_drink;
     508:	82 e0       	ldi	r24, 0x02	; 2
     50a:	80 93 f1 07 	sts	0x07F1, r24	; 0x8007f1 <rotate_state>
     50e:	08 95       	ret
			}
			else {
				current_position = drink;
     510:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <drink>
     514:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <current_position>
				rotate_flag = 0x00;
     518:	10 92 82 07 	sts	0x0782, r1	; 0x800782 <rotate_flag>
				rotate_state = Rotate_Wait;
     51c:	91 e0       	ldi	r25, 0x01	; 1
     51e:	90 93 f1 07 	sts	0x07F1, r25	; 0x8007f1 <rotate_state>
				USART_Send(current_position+1,1);
     522:	61 e0       	ldi	r22, 0x01	; 1
     524:	8f 5f       	subi	r24, 0xFF	; 255
     526:	d3 ce       	rjmp	.-602    	; 0x2ce <USART_Send>
     528:	08 95       	ret
			}
			break;
		
		default:
			rotate_state = Rotate_INIT;
     52a:	10 92 f1 07 	sts	0x07F1, r1	; 0x8007f1 <rotate_state>
     52e:	08 95       	ret

00000530 <RotateSecTask>:
		USART_Send(0xFF,usartNum);
	}
}

void Rotate_Init(){
	rotate_state = Rotate_INIT;
     530:	10 92 f1 07 	sts	0x07F1, r1	; 0x8007f1 <rotate_state>
}

void RotateSecTask() {
	Rotate_Init();
	for(;;) { 	
		Rotate_Tick();
     534:	17 df       	rcall	.-466    	; 0x364 <Rotate_Tick>
		vTaskDelay(6); 
     536:	86 e0       	ldi	r24, 0x06	; 6
     538:	90 e0       	ldi	r25, 0x00	; 0
     53a:	14 d6       	rcall	.+3112   	; 0x1164 <vTaskDelay>
	} 
     53c:	fb cf       	rjmp	.-10     	; 0x534 <RotateSecTask+0x4>

0000053e <Dispense_Tick>:
			break;
	}
}

void Dispense_Tick(){
	switch(dispense_state){ //actions
     53e:	80 91 f2 07 	lds	r24, 0x07F2	; 0x8007f2 <dispense_state>
     542:	82 30       	cpi	r24, 0x02	; 2
     544:	a1 f0       	breq	.+40     	; 0x56e <Dispense_Tick+0x30>
     546:	18 f4       	brcc	.+6      	; 0x54e <Dispense_Tick+0x10>
     548:	81 30       	cpi	r24, 0x01	; 1
     54a:	31 f0       	breq	.+12     	; 0x558 <Dispense_Tick+0x1a>
     54c:	4c c0       	rjmp	.+152    	; 0x5e6 <Dispense_Tick+0xa8>
     54e:	83 30       	cpi	r24, 0x03	; 3
     550:	39 f1       	breq	.+78     	; 0x5a0 <Dispense_Tick+0x62>
     552:	84 30       	cpi	r24, 0x04	; 4
     554:	79 f1       	breq	.+94     	; 0x5b4 <Dispense_Tick+0x76>
     556:	47 c0       	rjmp	.+142    	; 0x5e6 <Dispense_Tick+0xa8>
		case Dispense_INIT:
			break;
		case Dispense_Wait:
			dispense_cnt = 0;
     558:	10 92 8b 07 	sts	0x078B, r1	; 0x80078b <dispense_cnt+0x1>
     55c:	10 92 8a 07 	sts	0x078A, r1	; 0x80078a <dispense_cnt>
			dispense_index = 0;
     560:	10 92 89 07 	sts	0x0789, r1	; 0x800789 <dispense_index>
			dispense_hold_cnt = 0;
     564:	10 92 88 07 	sts	0x0788, r1	; 0x800788 <dispense_hold_cnt+0x1>
     568:	10 92 87 07 	sts	0x0787, r1	; 0x800787 <dispense_hold_cnt>
     56c:	4f c0       	rjmp	.+158    	; 0x60c <Dispense_Tick+0xce>
			break;
		case Dispense_Up:
			linear_stepper = backward_steps[dispense_index++];
     56e:	80 91 89 07 	lds	r24, 0x0789	; 0x800789 <dispense_index>
     572:	e8 2f       	mov	r30, r24
     574:	f0 e0       	ldi	r31, 0x00	; 0
     576:	e6 5d       	subi	r30, 0xD6	; 214
     578:	fe 4f       	sbci	r31, 0xFE	; 254
     57a:	90 81       	ld	r25, Z
     57c:	90 93 8c 07 	sts	0x078C, r25	; 0x80078c <linear_stepper>
     580:	8f 5f       	subi	r24, 0xFF	; 255
			dispense_index %= num_steps; 
     582:	60 91 29 01 	lds	r22, 0x0129	; 0x800129 <num_steps>
     586:	ad d6       	rcall	.+3418   	; 0x12e2 <__udivmodqi4>
     588:	90 93 89 07 	sts	0x0789, r25	; 0x800789 <dispense_index>
			dispense_cnt++;
     58c:	80 91 8a 07 	lds	r24, 0x078A	; 0x80078a <dispense_cnt>
     590:	90 91 8b 07 	lds	r25, 0x078B	; 0x80078b <dispense_cnt+0x1>
     594:	01 96       	adiw	r24, 0x01	; 1
     596:	90 93 8b 07 	sts	0x078B, r25	; 0x80078b <dispense_cnt+0x1>
     59a:	80 93 8a 07 	sts	0x078A, r24	; 0x80078a <dispense_cnt>
     59e:	50 c0       	rjmp	.+160    	; 0x640 <Dispense_Tick+0x102>
			break;
		case Dispense_Hold:
			dispense_hold_cnt++;
     5a0:	80 91 87 07 	lds	r24, 0x0787	; 0x800787 <dispense_hold_cnt>
     5a4:	90 91 88 07 	lds	r25, 0x0788	; 0x800788 <dispense_hold_cnt+0x1>
     5a8:	01 96       	adiw	r24, 0x01	; 1
     5aa:	90 93 88 07 	sts	0x0788, r25	; 0x800788 <dispense_hold_cnt+0x1>
     5ae:	80 93 87 07 	sts	0x0787, r24	; 0x800787 <dispense_hold_cnt>
     5b2:	5d c0       	rjmp	.+186    	; 0x66e <Dispense_Tick+0x130>
			break;
		case Dispense_Down:
			linear_stepper = forward_steps[dispense_index++];
     5b4:	80 91 89 07 	lds	r24, 0x0789	; 0x800789 <dispense_index>
     5b8:	e8 2f       	mov	r30, r24
     5ba:	f0 e0       	ldi	r31, 0x00	; 0
     5bc:	e2 5d       	subi	r30, 0xD2	; 210
     5be:	fe 4f       	sbci	r31, 0xFE	; 254
     5c0:	90 81       	ld	r25, Z
     5c2:	90 93 8c 07 	sts	0x078C, r25	; 0x80078c <linear_stepper>
     5c6:	8f 5f       	subi	r24, 0xFF	; 255
			dispense_index %= num_steps;
     5c8:	60 91 29 01 	lds	r22, 0x0129	; 0x800129 <num_steps>
     5cc:	8a d6       	rcall	.+3348   	; 0x12e2 <__udivmodqi4>
     5ce:	90 93 89 07 	sts	0x0789, r25	; 0x800789 <dispense_index>
			dispense_cnt++;
     5d2:	80 91 8a 07 	lds	r24, 0x078A	; 0x80078a <dispense_cnt>
     5d6:	90 91 8b 07 	lds	r25, 0x078B	; 0x80078b <dispense_cnt+0x1>
     5da:	01 96       	adiw	r24, 0x01	; 1
     5dc:	90 93 8b 07 	sts	0x078B, r25	; 0x80078b <dispense_cnt+0x1>
     5e0:	80 93 8a 07 	sts	0x078A, r24	; 0x80078a <dispense_cnt>
     5e4:	5f c0       	rjmp	.+190    	; 0x6a4 <Dispense_Tick+0x166>
			break;
		default:
			break;
	}
	switch(dispense_state){ //transition
     5e6:	82 30       	cpi	r24, 0x02	; 2
     5e8:	59 f1       	breq	.+86     	; 0x640 <Dispense_Tick+0x102>
     5ea:	30 f4       	brcc	.+12     	; 0x5f8 <Dispense_Tick+0xba>
     5ec:	88 23       	and	r24, r24
     5ee:	51 f0       	breq	.+20     	; 0x604 <Dispense_Tick+0xc6>
     5f0:	81 30       	cpi	r24, 0x01	; 1
     5f2:	09 f0       	breq	.+2      	; 0x5f6 <Dispense_Tick+0xb8>
     5f4:	74 c0       	rjmp	.+232    	; 0x6de <Dispense_Tick+0x1a0>
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <Dispense_Tick+0xce>
     5f8:	83 30       	cpi	r24, 0x03	; 3
     5fa:	c9 f1       	breq	.+114    	; 0x66e <Dispense_Tick+0x130>
     5fc:	84 30       	cpi	r24, 0x04	; 4
     5fe:	09 f0       	breq	.+2      	; 0x602 <Dispense_Tick+0xc4>
     600:	6e c0       	rjmp	.+220    	; 0x6de <Dispense_Tick+0x1a0>
     602:	50 c0       	rjmp	.+160    	; 0x6a4 <Dispense_Tick+0x166>
		case Dispense_INIT:
			dispense_state = Dispense_Wait;
     604:	81 e0       	ldi	r24, 0x01	; 1
     606:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <dispense_state>
			break;
     60a:	08 95       	ret
		case Dispense_Wait:
			if ((~PINB & 0x40)==0x40) { // if PINB6 is set to low, dispense
     60c:	1e 99       	sbic	0x03, 6	; 3
     60e:	08 c0       	rjmp	.+16     	; 0x620 <Dispense_Tick+0xe2>
				//PORTC = 0xFF;
				dispense_state = Dispense_Up;	
     610:	82 e0       	ldi	r24, 0x02	; 2
     612:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <dispense_state>
				dispense_cnt = 0;
     616:	10 92 8b 07 	sts	0x078B, r1	; 0x80078b <dispense_cnt+0x1>
     61a:	10 92 8a 07 	sts	0x078A, r1	; 0x80078a <dispense_cnt>
     61e:	08 95       	ret
			}
			else if (dispense_flag == 0x01) {
     620:	80 91 83 07 	lds	r24, 0x0783	; 0x800783 <dispense_flag>
     624:	81 30       	cpi	r24, 0x01	; 1
     626:	41 f4       	brne	.+16     	; 0x638 <Dispense_Tick+0xfa>
				dispense_state = Dispense_Up;
     628:	82 e0       	ldi	r24, 0x02	; 2
     62a:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <dispense_state>
				dispense_cnt = 0;
     62e:	10 92 8b 07 	sts	0x078B, r1	; 0x80078b <dispense_cnt+0x1>
     632:	10 92 8a 07 	sts	0x078A, r1	; 0x80078a <dispense_cnt>
     636:	08 95       	ret
			}
			else {
				dispense_state = Dispense_Wait;
     638:	81 e0       	ldi	r24, 0x01	; 1
     63a:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <dispense_state>
     63e:	08 95       	ret
			}
			break;
		case Dispense_Up:
			if (dispense_cnt >= dispense_totalcnt) {
     640:	20 91 8a 07 	lds	r18, 0x078A	; 0x80078a <dispense_cnt>
     644:	30 91 8b 07 	lds	r19, 0x078B	; 0x80078b <dispense_cnt+0x1>
     648:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <dispense_totalcnt>
     64c:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <dispense_totalcnt+0x1>
     650:	28 17       	cp	r18, r24
     652:	39 07       	cpc	r19, r25
     654:	40 f0       	brcs	.+16     	; 0x666 <Dispense_Tick+0x128>
				dispense_state = Dispense_Hold;
     656:	83 e0       	ldi	r24, 0x03	; 3
     658:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <dispense_state>
				dispense_cnt = 0;
     65c:	10 92 8b 07 	sts	0x078B, r1	; 0x80078b <dispense_cnt+0x1>
     660:	10 92 8a 07 	sts	0x078A, r1	; 0x80078a <dispense_cnt>
     664:	08 95       	ret
			}
			else {
				dispense_state = Dispense_Up;
     666:	82 e0       	ldi	r24, 0x02	; 2
     668:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <dispense_state>
     66c:	08 95       	ret
			}
			break;
		case Dispense_Hold:
			if (dispense_hold_cnt >= dispense_hold) {
     66e:	20 91 87 07 	lds	r18, 0x0787	; 0x800787 <dispense_hold_cnt>
     672:	30 91 88 07 	lds	r19, 0x0788	; 0x800788 <dispense_hold_cnt+0x1>
     676:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <dispense_hold>
     67a:	90 91 25 01 	lds	r25, 0x0125	; 0x800125 <dispense_hold+0x1>
     67e:	28 17       	cp	r18, r24
     680:	39 07       	cpc	r19, r25
     682:	60 f0       	brcs	.+24     	; 0x69c <Dispense_Tick+0x15e>
				dispense_state = Dispense_Down;
     684:	84 e0       	ldi	r24, 0x04	; 4
     686:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <dispense_state>
				dispense_hold_cnt = 0;
     68a:	10 92 88 07 	sts	0x0788, r1	; 0x800788 <dispense_hold_cnt+0x1>
     68e:	10 92 87 07 	sts	0x0787, r1	; 0x800787 <dispense_hold_cnt>
				dispense_cnt = 0;
     692:	10 92 8b 07 	sts	0x078B, r1	; 0x80078b <dispense_cnt+0x1>
     696:	10 92 8a 07 	sts	0x078A, r1	; 0x80078a <dispense_cnt>
     69a:	08 95       	ret
			}
			else {
				dispense_state = Dispense_Hold;
     69c:	83 e0       	ldi	r24, 0x03	; 3
     69e:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <dispense_state>
     6a2:	08 95       	ret
			}
			break;
		case Dispense_Down:
			if (dispense_cnt >= dispense_totalcnt) {
     6a4:	20 91 8a 07 	lds	r18, 0x078A	; 0x80078a <dispense_cnt>
     6a8:	30 91 8b 07 	lds	r19, 0x078B	; 0x80078b <dispense_cnt+0x1>
     6ac:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <dispense_totalcnt>
     6b0:	90 91 27 01 	lds	r25, 0x0127	; 0x800127 <dispense_totalcnt+0x1>
     6b4:	28 17       	cp	r18, r24
     6b6:	39 07       	cpc	r19, r25
     6b8:	70 f0       	brcs	.+28     	; 0x6d6 <Dispense_Tick+0x198>
				dispense_state = Dispense_Wait;
     6ba:	81 e0       	ldi	r24, 0x01	; 1
     6bc:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <dispense_state>
				dispense_hold_cnt = 0;
     6c0:	10 92 88 07 	sts	0x0788, r1	; 0x800788 <dispense_hold_cnt+0x1>
     6c4:	10 92 87 07 	sts	0x0787, r1	; 0x800787 <dispense_hold_cnt>
				dispense_cnt = 0;
     6c8:	10 92 8b 07 	sts	0x078B, r1	; 0x80078b <dispense_cnt+0x1>
     6cc:	10 92 8a 07 	sts	0x078A, r1	; 0x80078a <dispense_cnt>
				dispense_flag = 0;
     6d0:	10 92 83 07 	sts	0x0783, r1	; 0x800783 <dispense_flag>
     6d4:	08 95       	ret
			}
			else {
				dispense_state = Dispense_Down;
     6d6:	84 e0       	ldi	r24, 0x04	; 4
     6d8:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <dispense_state>
     6dc:	08 95       	ret
			}
			break;
		default:
			dispense_state = Dispense_Wait;
     6de:	81 e0       	ldi	r24, 0x01	; 1
     6e0:	80 93 f2 07 	sts	0x07F2, r24	; 0x8007f2 <dispense_state>
     6e4:	08 95       	ret

000006e6 <DispenseSecTask>:
void Rotate_Init(){
	rotate_state = Rotate_INIT;
}

void Dispense_Init(){
	dispense_state = Dispense_INIT;
     6e6:	10 92 f2 07 	sts	0x07F2, r1	; 0x8007f2 <dispense_state>
}

void DispenseSecTask() {
	Dispense_Init();
	for(;;) { 	
		Dispense_Tick();
     6ea:	29 df       	rcall	.-430    	; 0x53e <Dispense_Tick>
		vTaskDelay(8); 
     6ec:	88 e0       	ldi	r24, 0x08	; 8
     6ee:	90 e0       	ldi	r25, 0x00	; 0
     6f0:	39 d5       	rcall	.+2674   	; 0x1164 <vTaskDelay>
	} 
     6f2:	fb cf       	rjmp	.-10     	; 0x6ea <DispenseSecTask+0x4>

000006f4 <WritePORTA_Tick>:
		case WritePORTA_Wait:
			break;
		default:
			break;
	}
	switch (write_porta_state){ //transitions
     6f4:	80 91 f4 07 	lds	r24, 0x07F4	; 0x8007f4 <write_porta_state>
     6f8:	88 23       	and	r24, r24
     6fa:	19 f0       	breq	.+6      	; 0x702 <WritePORTA_Tick+0xe>
     6fc:	81 30       	cpi	r24, 0x01	; 1
     6fe:	31 f0       	breq	.+12     	; 0x70c <WritePORTA_Tick+0x18>
     700:	13 c0       	rjmp	.+38     	; 0x728 <WritePORTA_Tick+0x34>
		case WritePORTA_INIT:
			PORTA = 0;
     702:	12 b8       	out	0x02, r1	; 2
			write_porta_state = WritePORTA_Wait;
     704:	81 e0       	ldi	r24, 0x01	; 1
     706:	80 93 f4 07 	sts	0x07F4, r24	; 0x8007f4 <write_porta_state>
			break;
     70a:	08 95       	ret
		case WritePORTA_Wait:
			PORTA = rotate_stepper | (linear_stepper << 4);
     70c:	80 91 8c 07 	lds	r24, 0x078C	; 0x80078c <linear_stepper>
     710:	20 e1       	ldi	r18, 0x10	; 16
     712:	82 9f       	mul	r24, r18
     714:	c0 01       	movw	r24, r0
     716:	11 24       	eor	r1, r1
     718:	90 91 8d 07 	lds	r25, 0x078D	; 0x80078d <rotate_stepper>
     71c:	89 2b       	or	r24, r25
     71e:	82 b9       	out	0x02, r24	; 2
			write_porta_state = WritePORTA_Wait;
     720:	81 e0       	ldi	r24, 0x01	; 1
     722:	80 93 f4 07 	sts	0x07F4, r24	; 0x8007f4 <write_porta_state>
			break;
     726:	08 95       	ret
		default:
			write_porta_state = WritePORTA_Wait;
     728:	81 e0       	ldi	r24, 0x01	; 1
     72a:	80 93 f4 07 	sts	0x07F4, r24	; 0x8007f4 <write_porta_state>
			PORTA = 0;
     72e:	12 b8       	out	0x02, r1	; 2
     730:	08 95       	ret

00000732 <WritePORTASecTask>:
void Dispense_Init(){
	dispense_state = Dispense_INIT;
}

void WritePORTA_Init() {
	write_porta_state = WritePORTA_INIT;
     732:	10 92 f4 07 	sts	0x07F4, r1	; 0x8007f4 <write_porta_state>
}

void WritePORTASecTask() {
	WritePORTA_Init();
	for(;;) { 	
		WritePORTA_Tick();
     736:	de df       	rcall	.-68     	; 0x6f4 <WritePORTA_Tick>
		vTaskDelay(1); 
     738:	81 e0       	ldi	r24, 0x01	; 1
     73a:	90 e0       	ldi	r25, 0x00	; 0
     73c:	13 d5       	rcall	.+2598   	; 0x1164 <vTaskDelay>
	}
     73e:	fb cf       	rjmp	.-10     	; 0x736 <WritePORTASecTask+0x4>

00000740 <PollUSART_Tick>:
			break;	
	}
}

void PollUSART_Tick() {
	switch (poll_usart_state) { //actions
     740:	80 91 f0 07 	lds	r24, 0x07F0	; 0x8007f0 <poll_usart_state>
     744:	81 30       	cpi	r24, 0x01	; 1
     746:	b1 f4       	brne	.+44     	; 0x774 <PollUSART_Tick+0x34>
//Functionality - checks if USART has recieved data
//Parameter: usartNum specifies which USART is checked
//Returns: 1 if true else 0
unsigned char USART_HasReceived(unsigned char usartNum)
{
	return (usartNum != 1) ? (UCSR0A & (1 << RXC0)) : (UCSR1A & (1 << RXC1));
     748:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
		case PollUSART_INIT:
			break;
		case PollUSART_Wait:
			if (USART_HasReceived(0)) {
     74c:	88 23       	and	r24, r24
     74e:	14 f5       	brge	.+68     	; 0x794 <PollUSART_Tick+0x54>
				received_message = USART_Receive(0);	
     750:	80 e0       	ldi	r24, 0x00	; 0
     752:	cf dd       	rcall	.-1122   	; 0x2f2 <USART_Receive>
     754:	80 93 86 07 	sts	0x0786, r24	; 0x800786 <received_message>
				if (received_message == 0xAA) {
     758:	8a 3a       	cpi	r24, 0xAA	; 170
     75a:	51 f4       	brne	.+20     	; 0x770 <PollUSART_Tick+0x30>
					make_drink_flag = 0x01;
     75c:	81 e0       	ldi	r24, 0x01	; 1
     75e:	80 93 85 07 	sts	0x0785, r24	; 0x800785 <make_drink_flag>
					drink_to_make = USART_Receive(0);
     762:	80 e0       	ldi	r24, 0x00	; 0
     764:	c6 dd       	rcall	.-1140   	; 0x2f2 <USART_Receive>
     766:	80 93 84 07 	sts	0x0784, r24	; 0x800784 <drink_to_make>
					USART_Flush(0);
     76a:	80 e0       	ldi	r24, 0x00	; 0
     76c:	8f dd       	rcall	.-1250   	; 0x28c <USART_Flush>
     76e:	02 c0       	rjmp	.+4      	; 0x774 <PollUSART_Tick+0x34>
				}
				else {
					make_drink_flag = 0x00;
     770:	10 92 85 07 	sts	0x0785, r1	; 0x800785 <make_drink_flag>
			}
			break;
		default:
			break;
	}
	switch (poll_usart_state) { //transitions
     774:	80 91 f0 07 	lds	r24, 0x07F0	; 0x8007f0 <poll_usart_state>
     778:	88 23       	and	r24, r24
     77a:	19 f0       	breq	.+6      	; 0x782 <PollUSART_Tick+0x42>
     77c:	81 30       	cpi	r24, 0x01	; 1
     77e:	39 f4       	brne	.+14     	; 0x78e <PollUSART_Tick+0x4e>
     780:	08 95       	ret
		case PollUSART_INIT:
			poll_usart_state = PollUSART_Wait;
     782:	81 e0       	ldi	r24, 0x01	; 1
     784:	80 93 f0 07 	sts	0x07F0, r24	; 0x8007f0 <poll_usart_state>
			received_message = 0;
     788:	10 92 86 07 	sts	0x0786, r1	; 0x800786 <received_message>
			break;
     78c:	08 95       	ret
		case PollUSART_Wait:
			poll_usart_state = PollUSART_Wait;
			break;
		default:
			poll_usart_state = PollUSART_Wait;
     78e:	81 e0       	ldi	r24, 0x01	; 1
     790:	80 93 f0 07 	sts	0x07F0, r24	; 0x8007f0 <poll_usart_state>
     794:	08 95       	ret

00000796 <PollUSARTSecTask>:
void WritePORTA_Init() {
	write_porta_state = WritePORTA_INIT;
}

void PollUSART_Init() {
	poll_usart_state = PollUSART_INIT;
     796:	10 92 f0 07 	sts	0x07F0, r1	; 0x8007f0 <poll_usart_state>
}

void PollUSARTSecTask() {
	PollUSART_Init();
	for(;;) { 	
		PollUSART_Tick();
     79a:	d2 df       	rcall	.-92     	; 0x740 <PollUSART_Tick>
		vTaskDelay(1); 
     79c:	81 e0       	ldi	r24, 0x01	; 1
     79e:	90 e0       	ldi	r25, 0x00	; 0
     7a0:	e1 d4       	rcall	.+2498   	; 0x1164 <vTaskDelay>
	}
     7a2:	fb cf       	rjmp	.-10     	; 0x79a <PollUSARTSecTask+0x4>

000007a4 <MakeDrink_Tick>:
			poll_usart_state = PollUSART_Wait;
			break;
	}
}

void MakeDrink_Tick() {
     7a4:	cf 93       	push	r28
	switch (make_drink_state) { //actions
     7a6:	80 91 f5 07 	lds	r24, 0x07F5	; 0x8007f5 <make_drink_state>
     7aa:	81 30       	cpi	r24, 0x01	; 1
     7ac:	19 f4       	brne	.+6      	; 0x7b4 <MakeDrink_Tick+0x10>
		case MakeDrink_INIT:
			break;
		case MakeDrink_Wait:
			make_drink_cnt = 0;
     7ae:	10 92 81 07 	sts	0x0781, r1	; 0x800781 <make_drink_cnt>
     7b2:	1f c0       	rjmp	.+62     	; 0x7f2 <MakeDrink_Tick+0x4e>
		case MakeDrink_Dispense:
			break;
		default:
			break;
	}
	switch (make_drink_state) { //transitions
     7b4:	82 30       	cpi	r24, 0x02	; 2
     7b6:	a9 f1       	breq	.+106    	; 0x822 <MakeDrink_Tick+0x7e>
     7b8:	30 f4       	brcc	.+12     	; 0x7c6 <MakeDrink_Tick+0x22>
     7ba:	88 23       	and	r24, r24
     7bc:	59 f0       	breq	.+22     	; 0x7d4 <MakeDrink_Tick+0x30>
     7be:	81 30       	cpi	r24, 0x01	; 1
     7c0:	09 f0       	breq	.+2      	; 0x7c4 <MakeDrink_Tick+0x20>
     7c2:	7c c0       	rjmp	.+248    	; 0x8bc <MakeDrink_Tick+0x118>
     7c4:	16 c0       	rjmp	.+44     	; 0x7f2 <MakeDrink_Tick+0x4e>
     7c6:	83 30       	cpi	r24, 0x03	; 3
     7c8:	09 f4       	brne	.+2      	; 0x7cc <MakeDrink_Tick+0x28>
     7ca:	60 c0       	rjmp	.+192    	; 0x88c <MakeDrink_Tick+0xe8>
     7cc:	84 30       	cpi	r24, 0x04	; 4
     7ce:	09 f4       	brne	.+2      	; 0x7d2 <MakeDrink_Tick+0x2e>
     7d0:	68 c0       	rjmp	.+208    	; 0x8a2 <MakeDrink_Tick+0xfe>
     7d2:	74 c0       	rjmp	.+232    	; 0x8bc <MakeDrink_Tick+0x118>
		case MakeDrink_INIT:
			make_drink_state = MakeDrink_Wait;
     7d4:	81 e0       	ldi	r24, 0x01	; 1
     7d6:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <make_drink_state>
			make_drink_cnt = 0;
     7da:	10 92 81 07 	sts	0x0781, r1	; 0x800781 <make_drink_cnt>
			rotate_flag = 0;
     7de:	10 92 82 07 	sts	0x0782, r1	; 0x800782 <rotate_flag>
			dispense_flag = 0;
     7e2:	10 92 83 07 	sts	0x0783, r1	; 0x800783 <dispense_flag>
			USART_Send(current_position+1,1);
     7e6:	80 91 92 07 	lds	r24, 0x0792	; 0x800792 <current_position>
     7ea:	61 e0       	ldi	r22, 0x01	; 1
     7ec:	8f 5f       	subi	r24, 0xFF	; 255
     7ee:	6f dd       	rcall	.-1314   	; 0x2ce <USART_Send>
			break;
     7f0:	68 c0       	rjmp	.+208    	; 0x8c2 <MakeDrink_Tick+0x11e>
		case MakeDrink_Wait:
			if (make_drink_flag == 0x01 && rotate_flag == 0 && dispense_flag == 0) {
     7f2:	80 91 85 07 	lds	r24, 0x0785	; 0x800785 <make_drink_flag>
     7f6:	81 30       	cpi	r24, 0x01	; 1
     7f8:	81 f4       	brne	.+32     	; 0x81a <MakeDrink_Tick+0x76>
     7fa:	80 91 82 07 	lds	r24, 0x0782	; 0x800782 <rotate_flag>
     7fe:	81 11       	cpse	r24, r1
     800:	0c c0       	rjmp	.+24     	; 0x81a <MakeDrink_Tick+0x76>
     802:	80 91 83 07 	lds	r24, 0x0783	; 0x800783 <dispense_flag>
     806:	81 11       	cpse	r24, r1
     808:	08 c0       	rjmp	.+16     	; 0x81a <MakeDrink_Tick+0x76>
				USART_Send_String("page page2",0);
     80a:	60 e0       	ldi	r22, 0x00	; 0
     80c:	84 e3       	ldi	r24, 0x34	; 52
     80e:	91 e0       	ldi	r25, 0x01	; 1
     810:	82 dd       	rcall	.-1276   	; 0x316 <USART_Send_String>
				make_drink_state = MakeDrink;
     812:	82 e0       	ldi	r24, 0x02	; 2
     814:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <make_drink_state>
     818:	54 c0       	rjmp	.+168    	; 0x8c2 <MakeDrink_Tick+0x11e>
			}
			else {
				make_drink_state = MakeDrink_Wait;
     81a:	81 e0       	ldi	r24, 0x01	; 1
     81c:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <make_drink_state>
     820:	50 c0       	rjmp	.+160    	; 0x8c2 <MakeDrink_Tick+0x11e>
			}
			break;
		case MakeDrink:
			if (drinks[drink_to_make][make_drink_cnt]==0x01 && make_drink_cnt < 6) {
     822:	20 91 81 07 	lds	r18, 0x0781	; 0x800781 <make_drink_cnt>
     826:	80 91 84 07 	lds	r24, 0x0784	; 0x800784 <drink_to_make>
     82a:	90 e0       	ldi	r25, 0x00	; 0
     82c:	fc 01       	movw	r30, r24
     82e:	ee 0f       	add	r30, r30
     830:	ff 1f       	adc	r31, r31
     832:	e8 0f       	add	r30, r24
     834:	f9 1f       	adc	r31, r25
     836:	ee 0f       	add	r30, r30
     838:	ff 1f       	adc	r31, r31
     83a:	e2 0f       	add	r30, r18
     83c:	f1 1d       	adc	r31, r1
     83e:	e0 50       	subi	r30, 0x00	; 0
     840:	ff 4f       	sbci	r31, 0xFF	; 255
     842:	80 81       	ld	r24, Z
     844:	81 30       	cpi	r24, 0x01	; 1
     846:	59 f4       	brne	.+22     	; 0x85e <MakeDrink_Tick+0xba>
     848:	26 30       	cpi	r18, 0x06	; 6
     84a:	58 f4       	brcc	.+22     	; 0x862 <MakeDrink_Tick+0xbe>
				make_drink_state = MakeDrink_Rotate;
     84c:	83 e0       	ldi	r24, 0x03	; 3
     84e:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <make_drink_state>
				rotate_flag = 0x01;
     852:	81 e0       	ldi	r24, 0x01	; 1
     854:	80 93 82 07 	sts	0x0782, r24	; 0x800782 <rotate_flag>
				drink = make_drink_cnt;
     858:	20 93 8f 07 	sts	0x078F, r18	; 0x80078f <drink>
     85c:	32 c0       	rjmp	.+100    	; 0x8c2 <MakeDrink_Tick+0x11e>
			}
			else if (make_drink_cnt >= 6) {
     85e:	26 30       	cpi	r18, 0x06	; 6
     860:	70 f0       	brcs	.+28     	; 0x87e <MakeDrink_Tick+0xda>
				make_drink_state = MakeDrink_Wait;
     862:	c1 e0       	ldi	r28, 0x01	; 1
     864:	c0 93 f5 07 	sts	0x07F5, r28	; 0x8007f5 <make_drink_state>
				USART_Send_String("page page0",0);
     868:	60 e0       	ldi	r22, 0x00	; 0
     86a:	8f e3       	ldi	r24, 0x3F	; 63
     86c:	91 e0       	ldi	r25, 0x01	; 1
     86e:	53 dd       	rcall	.-1370   	; 0x316 <USART_Send_String>
				make_drink_flag = 0x00;
     870:	10 92 85 07 	sts	0x0785, r1	; 0x800785 <make_drink_flag>
				rotate_flag = 0x01;
     874:	c0 93 82 07 	sts	0x0782, r28	; 0x800782 <rotate_flag>
				drink = 0;
     878:	10 92 8f 07 	sts	0x078F, r1	; 0x80078f <drink>
     87c:	22 c0       	rjmp	.+68     	; 0x8c2 <MakeDrink_Tick+0x11e>
			}
			else {
				make_drink_cnt++;
     87e:	2f 5f       	subi	r18, 0xFF	; 255
     880:	20 93 81 07 	sts	0x0781, r18	; 0x800781 <make_drink_cnt>
				make_drink_state = MakeDrink;
     884:	82 e0       	ldi	r24, 0x02	; 2
     886:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <make_drink_state>
     88a:	1b c0       	rjmp	.+54     	; 0x8c2 <MakeDrink_Tick+0x11e>
			}
			break;
		case MakeDrink_Rotate:
			if (rotate_flag == 0x00) {
     88c:	80 91 82 07 	lds	r24, 0x0782	; 0x800782 <rotate_flag>
     890:	81 11       	cpse	r24, r1
     892:	17 c0       	rjmp	.+46     	; 0x8c2 <MakeDrink_Tick+0x11e>
				dispense_flag = 0x01;
     894:	81 e0       	ldi	r24, 0x01	; 1
     896:	80 93 83 07 	sts	0x0783, r24	; 0x800783 <dispense_flag>
				make_drink_state = MakeDrink_Dispense;
     89a:	84 e0       	ldi	r24, 0x04	; 4
     89c:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <make_drink_state>
     8a0:	10 c0       	rjmp	.+32     	; 0x8c2 <MakeDrink_Tick+0x11e>
			else {
				make_drink_state = MakeDrink_Rotate;
			}
			break;
		case MakeDrink_Dispense:
			if (dispense_flag == 0x00) {// && make_drink_cnt < 6) {
     8a2:	80 91 83 07 	lds	r24, 0x0783	; 0x800783 <dispense_flag>
     8a6:	81 11       	cpse	r24, r1
     8a8:	0c c0       	rjmp	.+24     	; 0x8c2 <MakeDrink_Tick+0x11e>
				make_drink_cnt++;
     8aa:	80 91 81 07 	lds	r24, 0x0781	; 0x800781 <make_drink_cnt>
     8ae:	8f 5f       	subi	r24, 0xFF	; 255
     8b0:	80 93 81 07 	sts	0x0781, r24	; 0x800781 <make_drink_cnt>
				make_drink_state = MakeDrink;
     8b4:	82 e0       	ldi	r24, 0x02	; 2
     8b6:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <make_drink_state>
     8ba:	03 c0       	rjmp	.+6      	; 0x8c2 <MakeDrink_Tick+0x11e>
			else {
				make_drink_state = MakeDrink_Dispense;
			}
			break;
		default:
			make_drink_state = MakeDrink_Wait;
     8bc:	81 e0       	ldi	r24, 0x01	; 1
     8be:	80 93 f5 07 	sts	0x07F5, r24	; 0x8007f5 <make_drink_state>
			break;
	}
}
     8c2:	cf 91       	pop	r28
     8c4:	08 95       	ret

000008c6 <MakeDrinkSecTask>:
void PollUSART_Init() {
	poll_usart_state = PollUSART_INIT;
}

void MakeDrink_Init() {
	make_drink_state = MakeDrink_INIT;
     8c6:	10 92 f5 07 	sts	0x07F5, r1	; 0x8007f5 <make_drink_state>
}

void MakeDrinkSecTask() {
	MakeDrink_Init();
	for(;;) { 	
		MakeDrink_Tick();
     8ca:	6c df       	rcall	.-296    	; 0x7a4 <MakeDrink_Tick>
		vTaskDelay(1); 
     8cc:	81 e0       	ldi	r24, 0x01	; 1
     8ce:	90 e0       	ldi	r25, 0x00	; 0
     8d0:	49 d4       	rcall	.+2194   	; 0x1164 <vTaskDelay>
	}
     8d2:	fb cf       	rjmp	.-10     	; 0x8ca <MakeDrinkSecTask+0x4>

000008d4 <StartSecPulse>:
}

void StartSecPulse(unsigned portBASE_TYPE Priority) {
     8d4:	af 92       	push	r10
     8d6:	bf 92       	push	r11
     8d8:	cf 92       	push	r12
     8da:	df 92       	push	r13
     8dc:	ef 92       	push	r14
     8de:	ff 92       	push	r15
     8e0:	0f 93       	push	r16
     8e2:	cf 93       	push	r28
	xTaskCreate(RotateSecTask, (signed portCHAR *)"RotateSecTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
     8e4:	a1 2c       	mov	r10, r1
     8e6:	b1 2c       	mov	r11, r1
     8e8:	c1 2c       	mov	r12, r1
     8ea:	d1 2c       	mov	r13, r1
     8ec:	e1 2c       	mov	r14, r1
     8ee:	f1 2c       	mov	r15, r1
     8f0:	08 2f       	mov	r16, r24
     8f2:	20 e0       	ldi	r18, 0x00	; 0
     8f4:	30 e0       	ldi	r19, 0x00	; 0
     8f6:	45 e5       	ldi	r20, 0x55	; 85
     8f8:	50 e0       	ldi	r21, 0x00	; 0
     8fa:	6a e4       	ldi	r22, 0x4A	; 74
     8fc:	71 e0       	ldi	r23, 0x01	; 1
     8fe:	88 e9       	ldi	r24, 0x98	; 152
     900:	92 e0       	ldi	r25, 0x02	; 2
     902:	cc d1       	rcall	.+920    	; 0xc9c <xTaskGenericCreate>
	xTaskCreate(DispenseSecTask, (signed portCHAR *)"DispenseSecTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
     904:	20 e0       	ldi	r18, 0x00	; 0
     906:	30 e0       	ldi	r19, 0x00	; 0
     908:	45 e5       	ldi	r20, 0x55	; 85
     90a:	50 e0       	ldi	r21, 0x00	; 0
     90c:	68 e5       	ldi	r22, 0x58	; 88
     90e:	71 e0       	ldi	r23, 0x01	; 1
     910:	83 e7       	ldi	r24, 0x73	; 115
     912:	93 e0       	ldi	r25, 0x03	; 3
     914:	c3 d1       	rcall	.+902    	; 0xc9c <xTaskGenericCreate>
	xTaskCreate(WritePORTASecTask, (signed portCHAR *)"WritePORTASecTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
     916:	20 e0       	ldi	r18, 0x00	; 0
     918:	30 e0       	ldi	r19, 0x00	; 0
     91a:	45 e5       	ldi	r20, 0x55	; 85
     91c:	50 e0       	ldi	r21, 0x00	; 0
     91e:	68 e6       	ldi	r22, 0x68	; 104
     920:	71 e0       	ldi	r23, 0x01	; 1
     922:	89 e9       	ldi	r24, 0x99	; 153
     924:	93 e0       	ldi	r25, 0x03	; 3
     926:	ba d1       	rcall	.+884    	; 0xc9c <xTaskGenericCreate>
	xTaskCreate(PollUSARTSecTask, (signed portCHAR *)"PollUSARTSecTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
     928:	20 e0       	ldi	r18, 0x00	; 0
     92a:	30 e0       	ldi	r19, 0x00	; 0
     92c:	45 e5       	ldi	r20, 0x55	; 85
     92e:	50 e0       	ldi	r21, 0x00	; 0
     930:	6a e7       	ldi	r22, 0x7A	; 122
     932:	71 e0       	ldi	r23, 0x01	; 1
     934:	8b ec       	ldi	r24, 0xCB	; 203
     936:	93 e0       	ldi	r25, 0x03	; 3
     938:	b1 d1       	rcall	.+866    	; 0xc9c <xTaskGenericCreate>
	xTaskCreate(MakeDrinkSecTask, (signed portCHAR *)"MakeDrinkSecTask", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
     93a:	20 e0       	ldi	r18, 0x00	; 0
     93c:	30 e0       	ldi	r19, 0x00	; 0
     93e:	45 e5       	ldi	r20, 0x55	; 85
     940:	50 e0       	ldi	r21, 0x00	; 0
     942:	6b e8       	ldi	r22, 0x8B	; 139
     944:	71 e0       	ldi	r23, 0x01	; 1
     946:	83 e6       	ldi	r24, 0x63	; 99
     948:	94 e0       	ldi	r25, 0x04	; 4
     94a:	a8 d1       	rcall	.+848    	; 0xc9c <xTaskGenericCreate>
}
     94c:	cf 91       	pop	r28
     94e:	0f 91       	pop	r16
     950:	ff 90       	pop	r15
     952:	ef 90       	pop	r14
     954:	df 90       	pop	r13
     956:	cf 90       	pop	r12
     958:	bf 90       	pop	r11
     95a:	af 90       	pop	r10
     95c:	08 95       	ret

0000095e <main>:

int main(void) { 
	DDRA = 0xFF; PORTA = 0x00;//Set PORTA as output
     95e:	8f ef       	ldi	r24, 0xFF	; 255
     960:	81 b9       	out	0x01, r24	; 1
     962:	12 b8       	out	0x02, r1	; 2
	DDRB = 0x00; PORTB = 0xFF;//Set PORTB as input
     964:	14 b8       	out	0x04, r1	; 4
     966:	85 b9       	out	0x05, r24	; 5
	DDRC = 0xFF; PORTC = 0x00;//Set PORTA as output
     968:	87 b9       	out	0x07, r24	; 7
     96a:	18 b8       	out	0x08, r1	; 8
	
	initUSART(0);
     96c:	80 e0       	ldi	r24, 0x00	; 0
     96e:	6c dc       	rcall	.-1832   	; 0x248 <initUSART>
	initUSART(1);
     970:	81 e0       	ldi	r24, 0x01	; 1
     972:	6a dc       	rcall	.-1836   	; 0x248 <initUSART>
	//Start Tasks  
	StartSecPulse(1);
     974:	81 e0       	ldi	r24, 0x01	; 1
     976:	ae df       	rcall	.-164    	; 0x8d4 <StartSecPulse>
	//RunSchedular 
	vTaskStartScheduler(); 
     978:	84 d2       	rcall	.+1288   	; 0xe82 <vTaskStartScheduler>
 
	return 0; 
     97a:	80 e0       	ldi	r24, 0x00	; 0
     97c:	90 e0       	ldi	r25, 0x00	; 0
     97e:	08 95       	ret

00000980 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     980:	31 e1       	ldi	r19, 0x11	; 17
     982:	fc 01       	movw	r30, r24
     984:	30 83       	st	Z, r19
     986:	31 97       	sbiw	r30, 0x01	; 1
     988:	22 e2       	ldi	r18, 0x22	; 34
     98a:	20 83       	st	Z, r18
     98c:	31 97       	sbiw	r30, 0x01	; 1
     98e:	a3 e3       	ldi	r26, 0x33	; 51
     990:	a0 83       	st	Z, r26
     992:	31 97       	sbiw	r30, 0x01	; 1
     994:	60 83       	st	Z, r22
     996:	31 97       	sbiw	r30, 0x01	; 1
     998:	70 83       	st	Z, r23
     99a:	31 97       	sbiw	r30, 0x01	; 1
     99c:	10 82       	st	Z, r1
     99e:	31 97       	sbiw	r30, 0x01	; 1
     9a0:	60 e8       	ldi	r22, 0x80	; 128
     9a2:	60 83       	st	Z, r22
     9a4:	31 97       	sbiw	r30, 0x01	; 1
     9a6:	10 82       	st	Z, r1
     9a8:	31 97       	sbiw	r30, 0x01	; 1
     9aa:	62 e0       	ldi	r22, 0x02	; 2
     9ac:	60 83       	st	Z, r22
     9ae:	31 97       	sbiw	r30, 0x01	; 1
     9b0:	63 e0       	ldi	r22, 0x03	; 3
     9b2:	60 83       	st	Z, r22
     9b4:	31 97       	sbiw	r30, 0x01	; 1
     9b6:	64 e0       	ldi	r22, 0x04	; 4
     9b8:	60 83       	st	Z, r22
     9ba:	31 97       	sbiw	r30, 0x01	; 1
     9bc:	65 e0       	ldi	r22, 0x05	; 5
     9be:	60 83       	st	Z, r22
     9c0:	31 97       	sbiw	r30, 0x01	; 1
     9c2:	66 e0       	ldi	r22, 0x06	; 6
     9c4:	60 83       	st	Z, r22
     9c6:	31 97       	sbiw	r30, 0x01	; 1
     9c8:	67 e0       	ldi	r22, 0x07	; 7
     9ca:	60 83       	st	Z, r22
     9cc:	31 97       	sbiw	r30, 0x01	; 1
     9ce:	68 e0       	ldi	r22, 0x08	; 8
     9d0:	60 83       	st	Z, r22
     9d2:	31 97       	sbiw	r30, 0x01	; 1
     9d4:	69 e0       	ldi	r22, 0x09	; 9
     9d6:	60 83       	st	Z, r22
     9d8:	31 97       	sbiw	r30, 0x01	; 1
     9da:	60 e1       	ldi	r22, 0x10	; 16
     9dc:	60 83       	st	Z, r22
     9de:	31 97       	sbiw	r30, 0x01	; 1
     9e0:	30 83       	st	Z, r19
     9e2:	31 97       	sbiw	r30, 0x01	; 1
     9e4:	32 e1       	ldi	r19, 0x12	; 18
     9e6:	30 83       	st	Z, r19
     9e8:	31 97       	sbiw	r30, 0x01	; 1
     9ea:	33 e1       	ldi	r19, 0x13	; 19
     9ec:	30 83       	st	Z, r19
     9ee:	31 97       	sbiw	r30, 0x01	; 1
     9f0:	34 e1       	ldi	r19, 0x14	; 20
     9f2:	30 83       	st	Z, r19
     9f4:	31 97       	sbiw	r30, 0x01	; 1
     9f6:	35 e1       	ldi	r19, 0x15	; 21
     9f8:	30 83       	st	Z, r19
     9fa:	31 97       	sbiw	r30, 0x01	; 1
     9fc:	36 e1       	ldi	r19, 0x16	; 22
     9fe:	30 83       	st	Z, r19
     a00:	31 97       	sbiw	r30, 0x01	; 1
     a02:	37 e1       	ldi	r19, 0x17	; 23
     a04:	30 83       	st	Z, r19
     a06:	31 97       	sbiw	r30, 0x01	; 1
     a08:	38 e1       	ldi	r19, 0x18	; 24
     a0a:	30 83       	st	Z, r19
     a0c:	31 97       	sbiw	r30, 0x01	; 1
     a0e:	39 e1       	ldi	r19, 0x19	; 25
     a10:	30 83       	st	Z, r19
     a12:	31 97       	sbiw	r30, 0x01	; 1
     a14:	30 e2       	ldi	r19, 0x20	; 32
     a16:	30 83       	st	Z, r19
     a18:	31 97       	sbiw	r30, 0x01	; 1
     a1a:	31 e2       	ldi	r19, 0x21	; 33
     a1c:	30 83       	st	Z, r19
     a1e:	31 97       	sbiw	r30, 0x01	; 1
     a20:	20 83       	st	Z, r18
     a22:	31 97       	sbiw	r30, 0x01	; 1
     a24:	23 e2       	ldi	r18, 0x23	; 35
     a26:	20 83       	st	Z, r18
     a28:	31 97       	sbiw	r30, 0x01	; 1
     a2a:	40 83       	st	Z, r20
     a2c:	31 97       	sbiw	r30, 0x01	; 1
     a2e:	50 83       	st	Z, r21
     a30:	31 97       	sbiw	r30, 0x01	; 1
     a32:	26 e2       	ldi	r18, 0x26	; 38
     a34:	20 83       	st	Z, r18
     a36:	31 97       	sbiw	r30, 0x01	; 1
     a38:	27 e2       	ldi	r18, 0x27	; 39
     a3a:	20 83       	st	Z, r18
     a3c:	31 97       	sbiw	r30, 0x01	; 1
     a3e:	28 e2       	ldi	r18, 0x28	; 40
     a40:	20 83       	st	Z, r18
     a42:	31 97       	sbiw	r30, 0x01	; 1
     a44:	29 e2       	ldi	r18, 0x29	; 41
     a46:	20 83       	st	Z, r18
     a48:	31 97       	sbiw	r30, 0x01	; 1
     a4a:	20 e3       	ldi	r18, 0x30	; 48
     a4c:	20 83       	st	Z, r18
     a4e:	31 97       	sbiw	r30, 0x01	; 1
     a50:	21 e3       	ldi	r18, 0x31	; 49
     a52:	20 83       	st	Z, r18
     a54:	86 97       	sbiw	r24, 0x26	; 38
     a56:	08 95       	ret

00000a58 <xPortStartScheduler>:
     a58:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     a5c:	8c e7       	ldi	r24, 0x7C	; 124
     a5e:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
     a62:	8b e0       	ldi	r24, 0x0B	; 11
     a64:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     a68:	ef e6       	ldi	r30, 0x6F	; 111
     a6a:	f0 e0       	ldi	r31, 0x00	; 0
     a6c:	80 81       	ld	r24, Z
     a6e:	82 60       	ori	r24, 0x02	; 2
     a70:	80 83       	st	Z, r24
     a72:	a0 91 ee 07 	lds	r26, 0x07EE	; 0x8007ee <pxCurrentTCB>
     a76:	b0 91 ef 07 	lds	r27, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
     a7a:	cd 91       	ld	r28, X+
     a7c:	cd bf       	out	0x3d, r28	; 61
     a7e:	dd 91       	ld	r29, X+
     a80:	de bf       	out	0x3e, r29	; 62
     a82:	ff 91       	pop	r31
     a84:	ef 91       	pop	r30
     a86:	df 91       	pop	r29
     a88:	cf 91       	pop	r28
     a8a:	bf 91       	pop	r27
     a8c:	af 91       	pop	r26
     a8e:	9f 91       	pop	r25
     a90:	8f 91       	pop	r24
     a92:	7f 91       	pop	r23
     a94:	6f 91       	pop	r22
     a96:	5f 91       	pop	r21
     a98:	4f 91       	pop	r20
     a9a:	3f 91       	pop	r19
     a9c:	2f 91       	pop	r18
     a9e:	1f 91       	pop	r17
     aa0:	0f 91       	pop	r16
     aa2:	ff 90       	pop	r15
     aa4:	ef 90       	pop	r14
     aa6:	df 90       	pop	r13
     aa8:	cf 90       	pop	r12
     aaa:	bf 90       	pop	r11
     aac:	af 90       	pop	r10
     aae:	9f 90       	pop	r9
     ab0:	8f 90       	pop	r8
     ab2:	7f 90       	pop	r7
     ab4:	6f 90       	pop	r6
     ab6:	5f 90       	pop	r5
     ab8:	4f 90       	pop	r4
     aba:	3f 90       	pop	r3
     abc:	2f 90       	pop	r2
     abe:	1f 90       	pop	r1
     ac0:	0f 90       	pop	r0
     ac2:	0f be       	out	0x3f, r0	; 63
     ac4:	0f 90       	pop	r0
     ac6:	08 95       	ret
     ac8:	81 e0       	ldi	r24, 0x01	; 1
     aca:	08 95       	ret

00000acc <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     acc:	0f 92       	push	r0
     ace:	0f b6       	in	r0, 0x3f	; 63
     ad0:	f8 94       	cli
     ad2:	0f 92       	push	r0
     ad4:	1f 92       	push	r1
     ad6:	11 24       	eor	r1, r1
     ad8:	2f 92       	push	r2
     ada:	3f 92       	push	r3
     adc:	4f 92       	push	r4
     ade:	5f 92       	push	r5
     ae0:	6f 92       	push	r6
     ae2:	7f 92       	push	r7
     ae4:	8f 92       	push	r8
     ae6:	9f 92       	push	r9
     ae8:	af 92       	push	r10
     aea:	bf 92       	push	r11
     aec:	cf 92       	push	r12
     aee:	df 92       	push	r13
     af0:	ef 92       	push	r14
     af2:	ff 92       	push	r15
     af4:	0f 93       	push	r16
     af6:	1f 93       	push	r17
     af8:	2f 93       	push	r18
     afa:	3f 93       	push	r19
     afc:	4f 93       	push	r20
     afe:	5f 93       	push	r21
     b00:	6f 93       	push	r22
     b02:	7f 93       	push	r23
     b04:	8f 93       	push	r24
     b06:	9f 93       	push	r25
     b08:	af 93       	push	r26
     b0a:	bf 93       	push	r27
     b0c:	cf 93       	push	r28
     b0e:	df 93       	push	r29
     b10:	ef 93       	push	r30
     b12:	ff 93       	push	r31
     b14:	a0 91 ee 07 	lds	r26, 0x07EE	; 0x8007ee <pxCurrentTCB>
     b18:	b0 91 ef 07 	lds	r27, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
     b1c:	0d b6       	in	r0, 0x3d	; 61
     b1e:	0d 92       	st	X+, r0
     b20:	0e b6       	in	r0, 0x3e	; 62
     b22:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     b24:	72 d3       	rcall	.+1764   	; 0x120a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     b26:	a0 91 ee 07 	lds	r26, 0x07EE	; 0x8007ee <pxCurrentTCB>
     b2a:	b0 91 ef 07 	lds	r27, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
     b2e:	cd 91       	ld	r28, X+
     b30:	cd bf       	out	0x3d, r28	; 61
     b32:	dd 91       	ld	r29, X+
     b34:	de bf       	out	0x3e, r29	; 62
     b36:	ff 91       	pop	r31
     b38:	ef 91       	pop	r30
     b3a:	df 91       	pop	r29
     b3c:	cf 91       	pop	r28
     b3e:	bf 91       	pop	r27
     b40:	af 91       	pop	r26
     b42:	9f 91       	pop	r25
     b44:	8f 91       	pop	r24
     b46:	7f 91       	pop	r23
     b48:	6f 91       	pop	r22
     b4a:	5f 91       	pop	r21
     b4c:	4f 91       	pop	r20
     b4e:	3f 91       	pop	r19
     b50:	2f 91       	pop	r18
     b52:	1f 91       	pop	r17
     b54:	0f 91       	pop	r16
     b56:	ff 90       	pop	r15
     b58:	ef 90       	pop	r14
     b5a:	df 90       	pop	r13
     b5c:	cf 90       	pop	r12
     b5e:	bf 90       	pop	r11
     b60:	af 90       	pop	r10
     b62:	9f 90       	pop	r9
     b64:	8f 90       	pop	r8
     b66:	7f 90       	pop	r7
     b68:	6f 90       	pop	r6
     b6a:	5f 90       	pop	r5
     b6c:	4f 90       	pop	r4
     b6e:	3f 90       	pop	r3
     b70:	2f 90       	pop	r2
     b72:	1f 90       	pop	r1
     b74:	0f 90       	pop	r0
     b76:	0f be       	out	0x3f, r0	; 63
     b78:	0f 90       	pop	r0

	asm volatile ( "ret" );
     b7a:	08 95       	ret

00000b7c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     b7c:	0f 92       	push	r0
     b7e:	0f b6       	in	r0, 0x3f	; 63
     b80:	f8 94       	cli
     b82:	0f 92       	push	r0
     b84:	1f 92       	push	r1
     b86:	11 24       	eor	r1, r1
     b88:	2f 92       	push	r2
     b8a:	3f 92       	push	r3
     b8c:	4f 92       	push	r4
     b8e:	5f 92       	push	r5
     b90:	6f 92       	push	r6
     b92:	7f 92       	push	r7
     b94:	8f 92       	push	r8
     b96:	9f 92       	push	r9
     b98:	af 92       	push	r10
     b9a:	bf 92       	push	r11
     b9c:	cf 92       	push	r12
     b9e:	df 92       	push	r13
     ba0:	ef 92       	push	r14
     ba2:	ff 92       	push	r15
     ba4:	0f 93       	push	r16
     ba6:	1f 93       	push	r17
     ba8:	2f 93       	push	r18
     baa:	3f 93       	push	r19
     bac:	4f 93       	push	r20
     bae:	5f 93       	push	r21
     bb0:	6f 93       	push	r22
     bb2:	7f 93       	push	r23
     bb4:	8f 93       	push	r24
     bb6:	9f 93       	push	r25
     bb8:	af 93       	push	r26
     bba:	bf 93       	push	r27
     bbc:	cf 93       	push	r28
     bbe:	df 93       	push	r29
     bc0:	ef 93       	push	r30
     bc2:	ff 93       	push	r31
     bc4:	a0 91 ee 07 	lds	r26, 0x07EE	; 0x8007ee <pxCurrentTCB>
     bc8:	b0 91 ef 07 	lds	r27, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
     bcc:	0d b6       	in	r0, 0x3d	; 61
     bce:	0d 92       	st	X+, r0
     bd0:	0e b6       	in	r0, 0x3e	; 62
     bd2:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     bd4:	85 d1       	rcall	.+778    	; 0xee0 <vTaskIncrementTick>
	vTaskSwitchContext();
     bd6:	19 d3       	rcall	.+1586   	; 0x120a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     bd8:	a0 91 ee 07 	lds	r26, 0x07EE	; 0x8007ee <pxCurrentTCB>
     bdc:	b0 91 ef 07 	lds	r27, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
     be0:	cd 91       	ld	r28, X+
     be2:	cd bf       	out	0x3d, r28	; 61
     be4:	dd 91       	ld	r29, X+
     be6:	de bf       	out	0x3e, r29	; 62
     be8:	ff 91       	pop	r31
     bea:	ef 91       	pop	r30
     bec:	df 91       	pop	r29
     bee:	cf 91       	pop	r28
     bf0:	bf 91       	pop	r27
     bf2:	af 91       	pop	r26
     bf4:	9f 91       	pop	r25
     bf6:	8f 91       	pop	r24
     bf8:	7f 91       	pop	r23
     bfa:	6f 91       	pop	r22
     bfc:	5f 91       	pop	r21
     bfe:	4f 91       	pop	r20
     c00:	3f 91       	pop	r19
     c02:	2f 91       	pop	r18
     c04:	1f 91       	pop	r17
     c06:	0f 91       	pop	r16
     c08:	ff 90       	pop	r15
     c0a:	ef 90       	pop	r14
     c0c:	df 90       	pop	r13
     c0e:	cf 90       	pop	r12
     c10:	bf 90       	pop	r11
     c12:	af 90       	pop	r10
     c14:	9f 90       	pop	r9
     c16:	8f 90       	pop	r8
     c18:	7f 90       	pop	r7
     c1a:	6f 90       	pop	r6
     c1c:	5f 90       	pop	r5
     c1e:	4f 90       	pop	r4
     c20:	3f 90       	pop	r3
     c22:	2f 90       	pop	r2
     c24:	1f 90       	pop	r1
     c26:	0f 90       	pop	r0
     c28:	0f be       	out	0x3f, r0	; 63
     c2a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     c2c:	08 95       	ret

00000c2e <__vector_13>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     c2e:	a6 df       	rcall	.-180    	; 0xb7c <vPortYieldFromTick>
		asm volatile ( "reti" );
     c30:	18 95       	reti

00000c32 <prvAddCurrentTaskToDelayedList>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
     c32:	cf 93       	push	r28
     c34:	df 93       	push	r29
     c36:	ec 01       	movw	r28, r24
     c38:	e0 91 ee 07 	lds	r30, 0x07EE	; 0x8007ee <pxCurrentTCB>
     c3c:	f0 91 ef 07 	lds	r31, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
     c40:	93 83       	std	Z+3, r25	; 0x03
     c42:	82 83       	std	Z+2, r24	; 0x02
     c44:	80 91 9e 07 	lds	r24, 0x079E	; 0x80079e <xTickCount>
     c48:	90 91 9f 07 	lds	r25, 0x079F	; 0x80079f <xTickCount+0x1>
     c4c:	c8 17       	cp	r28, r24
     c4e:	d9 07       	cpc	r29, r25
     c50:	60 f4       	brcc	.+24     	; 0xc6a <prvAddCurrentTaskToDelayedList+0x38>
     c52:	60 91 ee 07 	lds	r22, 0x07EE	; 0x8007ee <pxCurrentTCB>
     c56:	70 91 ef 07 	lds	r23, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
     c5a:	80 91 b4 07 	lds	r24, 0x07B4	; 0x8007b4 <pxOverflowDelayedTaskList>
     c5e:	90 91 b5 07 	lds	r25, 0x07B5	; 0x8007b5 <pxOverflowDelayedTaskList+0x1>
     c62:	6e 5f       	subi	r22, 0xFE	; 254
     c64:	7f 4f       	sbci	r23, 0xFF	; 255
     c66:	8f da       	rcall	.-2786   	; 0x186 <vListInsert>
     c68:	16 c0       	rjmp	.+44     	; 0xc96 <prvAddCurrentTaskToDelayedList+0x64>
     c6a:	60 91 ee 07 	lds	r22, 0x07EE	; 0x8007ee <pxCurrentTCB>
     c6e:	70 91 ef 07 	lds	r23, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
     c72:	80 91 b6 07 	lds	r24, 0x07B6	; 0x8007b6 <pxDelayedTaskList>
     c76:	90 91 b7 07 	lds	r25, 0x07B7	; 0x8007b7 <pxDelayedTaskList+0x1>
     c7a:	6e 5f       	subi	r22, 0xFE	; 254
     c7c:	7f 4f       	sbci	r23, 0xFF	; 255
     c7e:	83 da       	rcall	.-2810   	; 0x186 <vListInsert>
     c80:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <xNextTaskUnblockTime>
     c84:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <xNextTaskUnblockTime+0x1>
     c88:	c8 17       	cp	r28, r24
     c8a:	d9 07       	cpc	r29, r25
     c8c:	20 f4       	brcc	.+8      	; 0xc96 <prvAddCurrentTaskToDelayedList+0x64>
     c8e:	d0 93 33 01 	sts	0x0133, r29	; 0x800133 <xNextTaskUnblockTime+0x1>
     c92:	c0 93 32 01 	sts	0x0132, r28	; 0x800132 <xNextTaskUnblockTime>
     c96:	df 91       	pop	r29
     c98:	cf 91       	pop	r28
     c9a:	08 95       	ret

00000c9c <xTaskGenericCreate>:
     c9c:	4f 92       	push	r4
     c9e:	5f 92       	push	r5
     ca0:	6f 92       	push	r6
     ca2:	7f 92       	push	r7
     ca4:	8f 92       	push	r8
     ca6:	9f 92       	push	r9
     ca8:	af 92       	push	r10
     caa:	bf 92       	push	r11
     cac:	cf 92       	push	r12
     cae:	df 92       	push	r13
     cb0:	ef 92       	push	r14
     cb2:	ff 92       	push	r15
     cb4:	0f 93       	push	r16
     cb6:	1f 93       	push	r17
     cb8:	cf 93       	push	r28
     cba:	df 93       	push	r29
     cbc:	5c 01       	movw	r10, r24
     cbe:	4b 01       	movw	r8, r22
     cc0:	3a 01       	movw	r6, r20
     cc2:	29 01       	movw	r4, r18
     cc4:	81 e2       	ldi	r24, 0x21	; 33
     cc6:	90 e0       	ldi	r25, 0x00	; 0
     cc8:	00 da       	rcall	.-3072   	; 0xca <pvPortMalloc>
     cca:	ec 01       	movw	r28, r24
     ccc:	89 2b       	or	r24, r25
     cce:	09 f4       	brne	.+2      	; 0xcd2 <xTaskGenericCreate+0x36>
     cd0:	c6 c0       	rjmp	.+396    	; 0xe5e <xTaskGenericCreate+0x1c2>
     cd2:	c1 14       	cp	r12, r1
     cd4:	d1 04       	cpc	r13, r1
     cd6:	09 f0       	breq	.+2      	; 0xcda <xTaskGenericCreate+0x3e>
     cd8:	be c0       	rjmp	.+380    	; 0xe56 <xTaskGenericCreate+0x1ba>
     cda:	c3 01       	movw	r24, r6
     cdc:	f6 d9       	rcall	.-3092   	; 0xca <pvPortMalloc>
     cde:	98 8f       	std	Y+24, r25	; 0x18
     ce0:	8f 8b       	std	Y+23, r24	; 0x17
     ce2:	00 97       	sbiw	r24, 0x00	; 0
     ce4:	19 f4       	brne	.+6      	; 0xcec <xTaskGenericCreate+0x50>
     ce6:	ce 01       	movw	r24, r28
     ce8:	14 da       	rcall	.-3032   	; 0x112 <vPortFree>
     cea:	b9 c0       	rjmp	.+370    	; 0xe5e <xTaskGenericCreate+0x1c2>
     cec:	a3 01       	movw	r20, r6
     cee:	65 ea       	ldi	r22, 0xA5	; 165
     cf0:	70 e0       	ldi	r23, 0x00	; 0
     cf2:	03 d3       	rcall	.+1542   	; 0x12fa <memset>
     cf4:	93 01       	movw	r18, r6
     cf6:	21 50       	subi	r18, 0x01	; 1
     cf8:	31 09       	sbc	r19, r1
     cfa:	8f 89       	ldd	r24, Y+23	; 0x17
     cfc:	98 8d       	ldd	r25, Y+24	; 0x18
     cfe:	3c 01       	movw	r6, r24
     d00:	62 0e       	add	r6, r18
     d02:	73 1e       	adc	r7, r19
     d04:	48 e0       	ldi	r20, 0x08	; 8
     d06:	50 e0       	ldi	r21, 0x00	; 0
     d08:	b4 01       	movw	r22, r8
     d0a:	ce 01       	movw	r24, r28
     d0c:	49 96       	adiw	r24, 0x19	; 25
     d0e:	fc d2       	rcall	.+1528   	; 0x1308 <strncpy>
     d10:	18 a2       	std	Y+32, r1	; 0x20
     d12:	10 2f       	mov	r17, r16
     d14:	04 30       	cpi	r16, 0x04	; 4
     d16:	08 f0       	brcs	.+2      	; 0xd1a <xTaskGenericCreate+0x7e>
     d18:	13 e0       	ldi	r17, 0x03	; 3
     d1a:	1e 8b       	std	Y+22, r17	; 0x16
     d1c:	6e 01       	movw	r12, r28
     d1e:	82 e0       	ldi	r24, 0x02	; 2
     d20:	c8 0e       	add	r12, r24
     d22:	d1 1c       	adc	r13, r1
     d24:	c6 01       	movw	r24, r12
     d26:	04 da       	rcall	.-3064   	; 0x130 <vListInitialiseItem>
     d28:	ce 01       	movw	r24, r28
     d2a:	0c 96       	adiw	r24, 0x0c	; 12
     d2c:	01 da       	rcall	.-3070   	; 0x130 <vListInitialiseItem>
     d2e:	d9 87       	std	Y+9, r29	; 0x09
     d30:	c8 87       	std	Y+8, r28	; 0x08
     d32:	84 e0       	ldi	r24, 0x04	; 4
     d34:	90 e0       	ldi	r25, 0x00	; 0
     d36:	81 1b       	sub	r24, r17
     d38:	91 09       	sbc	r25, r1
     d3a:	9d 87       	std	Y+13, r25	; 0x0d
     d3c:	8c 87       	std	Y+12, r24	; 0x0c
     d3e:	db 8b       	std	Y+19, r29	; 0x13
     d40:	ca 8b       	std	Y+18, r28	; 0x12
     d42:	a2 01       	movw	r20, r4
     d44:	b5 01       	movw	r22, r10
     d46:	c3 01       	movw	r24, r6
     d48:	1b de       	rcall	.-970    	; 0x980 <pxPortInitialiseStack>
     d4a:	99 83       	std	Y+1, r25	; 0x01
     d4c:	88 83       	st	Y, r24
     d4e:	e1 14       	cp	r14, r1
     d50:	f1 04       	cpc	r15, r1
     d52:	19 f0       	breq	.+6      	; 0xd5a <xTaskGenericCreate+0xbe>
     d54:	f7 01       	movw	r30, r14
     d56:	d1 83       	std	Z+1, r29	; 0x01
     d58:	c0 83       	st	Z, r28
     d5a:	0f b6       	in	r0, 0x3f	; 63
     d5c:	f8 94       	cli
     d5e:	0f 92       	push	r0
     d60:	80 91 a0 07 	lds	r24, 0x07A0	; 0x8007a0 <uxCurrentNumberOfTasks>
     d64:	8f 5f       	subi	r24, 0xFF	; 255
     d66:	80 93 a0 07 	sts	0x07A0, r24	; 0x8007a0 <uxCurrentNumberOfTasks>
     d6a:	80 91 ee 07 	lds	r24, 0x07EE	; 0x8007ee <pxCurrentTCB>
     d6e:	90 91 ef 07 	lds	r25, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
     d72:	89 2b       	or	r24, r25
     d74:	69 f5       	brne	.+90     	; 0xdd0 <xTaskGenericCreate+0x134>
     d76:	d0 93 ef 07 	sts	0x07EF, r29	; 0x8007ef <pxCurrentTCB+0x1>
     d7a:	c0 93 ee 07 	sts	0x07EE, r28	; 0x8007ee <pxCurrentTCB>
     d7e:	80 91 a0 07 	lds	r24, 0x07A0	; 0x8007a0 <uxCurrentNumberOfTasks>
     d82:	81 30       	cpi	r24, 0x01	; 1
     d84:	a1 f5       	brne	.+104    	; 0xdee <xTaskGenericCreate+0x152>
     d86:	8a ec       	ldi	r24, 0xCA	; 202
     d88:	97 e0       	ldi	r25, 0x07	; 7
     d8a:	c4 d9       	rcall	.-3192   	; 0x114 <vListInitialise>
     d8c:	83 ed       	ldi	r24, 0xD3	; 211
     d8e:	97 e0       	ldi	r25, 0x07	; 7
     d90:	c1 d9       	rcall	.-3198   	; 0x114 <vListInitialise>
     d92:	8c ed       	ldi	r24, 0xDC	; 220
     d94:	97 e0       	ldi	r25, 0x07	; 7
     d96:	be d9       	rcall	.-3204   	; 0x114 <vListInitialise>
     d98:	85 ee       	ldi	r24, 0xE5	; 229
     d9a:	97 e0       	ldi	r25, 0x07	; 7
     d9c:	bb d9       	rcall	.-3210   	; 0x114 <vListInitialise>
     d9e:	81 ec       	ldi	r24, 0xC1	; 193
     da0:	97 e0       	ldi	r25, 0x07	; 7
     da2:	b8 d9       	rcall	.-3216   	; 0x114 <vListInitialise>
     da4:	88 eb       	ldi	r24, 0xB8	; 184
     da6:	97 e0       	ldi	r25, 0x07	; 7
     da8:	b5 d9       	rcall	.-3222   	; 0x114 <vListInitialise>
     daa:	8b ea       	ldi	r24, 0xAB	; 171
     dac:	97 e0       	ldi	r25, 0x07	; 7
     dae:	b2 d9       	rcall	.-3228   	; 0x114 <vListInitialise>
     db0:	82 ea       	ldi	r24, 0xA2	; 162
     db2:	97 e0       	ldi	r25, 0x07	; 7
     db4:	af d9       	rcall	.-3234   	; 0x114 <vListInitialise>
     db6:	81 ec       	ldi	r24, 0xC1	; 193
     db8:	97 e0       	ldi	r25, 0x07	; 7
     dba:	90 93 b7 07 	sts	0x07B7, r25	; 0x8007b7 <pxDelayedTaskList+0x1>
     dbe:	80 93 b6 07 	sts	0x07B6, r24	; 0x8007b6 <pxDelayedTaskList>
     dc2:	88 eb       	ldi	r24, 0xB8	; 184
     dc4:	97 e0       	ldi	r25, 0x07	; 7
     dc6:	90 93 b5 07 	sts	0x07B5, r25	; 0x8007b5 <pxOverflowDelayedTaskList+0x1>
     dca:	80 93 b4 07 	sts	0x07B4, r24	; 0x8007b4 <pxOverflowDelayedTaskList>
     dce:	0f c0       	rjmp	.+30     	; 0xdee <xTaskGenericCreate+0x152>
     dd0:	80 91 9b 07 	lds	r24, 0x079B	; 0x80079b <xSchedulerRunning>
     dd4:	81 11       	cpse	r24, r1
     dd6:	0b c0       	rjmp	.+22     	; 0xdee <xTaskGenericCreate+0x152>
     dd8:	e0 91 ee 07 	lds	r30, 0x07EE	; 0x8007ee <pxCurrentTCB>
     ddc:	f0 91 ef 07 	lds	r31, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
     de0:	86 89       	ldd	r24, Z+22	; 0x16
     de2:	08 17       	cp	r16, r24
     de4:	20 f0       	brcs	.+8      	; 0xdee <xTaskGenericCreate+0x152>
     de6:	d0 93 ef 07 	sts	0x07EF, r29	; 0x8007ef <pxCurrentTCB+0x1>
     dea:	c0 93 ee 07 	sts	0x07EE, r28	; 0x8007ee <pxCurrentTCB>
     dee:	8e 89       	ldd	r24, Y+22	; 0x16
     df0:	90 91 9d 07 	lds	r25, 0x079D	; 0x80079d <uxTopUsedPriority>
     df4:	98 17       	cp	r25, r24
     df6:	10 f4       	brcc	.+4      	; 0xdfc <xTaskGenericCreate+0x160>
     df8:	80 93 9d 07 	sts	0x079D, r24	; 0x80079d <uxTopUsedPriority>
     dfc:	90 91 96 07 	lds	r25, 0x0796	; 0x800796 <uxTaskNumber>
     e00:	9f 5f       	subi	r25, 0xFF	; 255
     e02:	90 93 96 07 	sts	0x0796, r25	; 0x800796 <uxTaskNumber>
     e06:	90 91 9c 07 	lds	r25, 0x079C	; 0x80079c <uxTopReadyPriority>
     e0a:	98 17       	cp	r25, r24
     e0c:	10 f4       	brcc	.+4      	; 0xe12 <xTaskGenericCreate+0x176>
     e0e:	80 93 9c 07 	sts	0x079C, r24	; 0x80079c <uxTopReadyPriority>
     e12:	90 e0       	ldi	r25, 0x00	; 0
     e14:	9c 01       	movw	r18, r24
     e16:	22 0f       	add	r18, r18
     e18:	33 1f       	adc	r19, r19
     e1a:	22 0f       	add	r18, r18
     e1c:	33 1f       	adc	r19, r19
     e1e:	22 0f       	add	r18, r18
     e20:	33 1f       	adc	r19, r19
     e22:	82 0f       	add	r24, r18
     e24:	93 1f       	adc	r25, r19
     e26:	b6 01       	movw	r22, r12
     e28:	86 53       	subi	r24, 0x36	; 54
     e2a:	98 4f       	sbci	r25, 0xF8	; 248
     e2c:	85 d9       	rcall	.-3318   	; 0x138 <vListInsertEnd>
     e2e:	0f 90       	pop	r0
     e30:	0f be       	out	0x3f, r0	; 63
     e32:	80 91 9b 07 	lds	r24, 0x079B	; 0x80079b <xSchedulerRunning>
     e36:	88 23       	and	r24, r24
     e38:	51 f0       	breq	.+20     	; 0xe4e <xTaskGenericCreate+0x1b2>
     e3a:	e0 91 ee 07 	lds	r30, 0x07EE	; 0x8007ee <pxCurrentTCB>
     e3e:	f0 91 ef 07 	lds	r31, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
     e42:	86 89       	ldd	r24, Z+22	; 0x16
     e44:	80 17       	cp	r24, r16
     e46:	28 f4       	brcc	.+10     	; 0xe52 <xTaskGenericCreate+0x1b6>
     e48:	41 de       	rcall	.-894    	; 0xacc <vPortYield>
     e4a:	81 e0       	ldi	r24, 0x01	; 1
     e4c:	09 c0       	rjmp	.+18     	; 0xe60 <xTaskGenericCreate+0x1c4>
     e4e:	81 e0       	ldi	r24, 0x01	; 1
     e50:	07 c0       	rjmp	.+14     	; 0xe60 <xTaskGenericCreate+0x1c4>
     e52:	81 e0       	ldi	r24, 0x01	; 1
     e54:	05 c0       	rjmp	.+10     	; 0xe60 <xTaskGenericCreate+0x1c4>
     e56:	d8 8e       	std	Y+24, r13	; 0x18
     e58:	cf 8a       	std	Y+23, r12	; 0x17
     e5a:	c6 01       	movw	r24, r12
     e5c:	47 cf       	rjmp	.-370    	; 0xcec <xTaskGenericCreate+0x50>
     e5e:	8f ef       	ldi	r24, 0xFF	; 255
     e60:	df 91       	pop	r29
     e62:	cf 91       	pop	r28
     e64:	1f 91       	pop	r17
     e66:	0f 91       	pop	r16
     e68:	ff 90       	pop	r15
     e6a:	ef 90       	pop	r14
     e6c:	df 90       	pop	r13
     e6e:	cf 90       	pop	r12
     e70:	bf 90       	pop	r11
     e72:	af 90       	pop	r10
     e74:	9f 90       	pop	r9
     e76:	8f 90       	pop	r8
     e78:	7f 90       	pop	r7
     e7a:	6f 90       	pop	r6
     e7c:	5f 90       	pop	r5
     e7e:	4f 90       	pop	r4
     e80:	08 95       	ret

00000e82 <vTaskStartScheduler>:
     e82:	af 92       	push	r10
     e84:	bf 92       	push	r11
     e86:	cf 92       	push	r12
     e88:	df 92       	push	r13
     e8a:	ef 92       	push	r14
     e8c:	ff 92       	push	r15
     e8e:	0f 93       	push	r16
     e90:	a1 2c       	mov	r10, r1
     e92:	b1 2c       	mov	r11, r1
     e94:	c1 2c       	mov	r12, r1
     e96:	d1 2c       	mov	r13, r1
     e98:	e1 2c       	mov	r14, r1
     e9a:	f1 2c       	mov	r15, r1
     e9c:	00 e0       	ldi	r16, 0x00	; 0
     e9e:	20 e0       	ldi	r18, 0x00	; 0
     ea0:	30 e0       	ldi	r19, 0x00	; 0
     ea2:	45 e5       	ldi	r20, 0x55	; 85
     ea4:	50 e0       	ldi	r21, 0x00	; 0
     ea6:	6c e9       	ldi	r22, 0x9C	; 156
     ea8:	71 e0       	ldi	r23, 0x01	; 1
     eaa:	8d ec       	ldi	r24, 0xCD	; 205
     eac:	98 e0       	ldi	r25, 0x08	; 8
     eae:	f6 de       	rcall	.-532    	; 0xc9c <xTaskGenericCreate>
     eb0:	81 30       	cpi	r24, 0x01	; 1
     eb2:	41 f4       	brne	.+16     	; 0xec4 <vTaskStartScheduler+0x42>
     eb4:	f8 94       	cli
     eb6:	80 93 9b 07 	sts	0x079B, r24	; 0x80079b <xSchedulerRunning>
     eba:	10 92 9f 07 	sts	0x079F, r1	; 0x80079f <xTickCount+0x1>
     ebe:	10 92 9e 07 	sts	0x079E, r1	; 0x80079e <xTickCount>
     ec2:	ca dd       	rcall	.-1132   	; 0xa58 <xPortStartScheduler>
     ec4:	0f 91       	pop	r16
     ec6:	ff 90       	pop	r15
     ec8:	ef 90       	pop	r14
     eca:	df 90       	pop	r13
     ecc:	cf 90       	pop	r12
     ece:	bf 90       	pop	r11
     ed0:	af 90       	pop	r10
     ed2:	08 95       	ret

00000ed4 <vTaskSuspendAll>:
     ed4:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <uxSchedulerSuspended>
     ed8:	8f 5f       	subi	r24, 0xFF	; 255
     eda:	80 93 9a 07 	sts	0x079A, r24	; 0x80079a <uxSchedulerSuspended>
     ede:	08 95       	ret

00000ee0 <vTaskIncrementTick>:
     ee0:	0f 93       	push	r16
     ee2:	1f 93       	push	r17
     ee4:	cf 93       	push	r28
     ee6:	df 93       	push	r29
     ee8:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <uxSchedulerSuspended>
     eec:	81 11       	cpse	r24, r1
     eee:	af c0       	rjmp	.+350    	; 0x104e <vTaskIncrementTick+0x16e>
     ef0:	80 91 9e 07 	lds	r24, 0x079E	; 0x80079e <xTickCount>
     ef4:	90 91 9f 07 	lds	r25, 0x079F	; 0x80079f <xTickCount+0x1>
     ef8:	01 96       	adiw	r24, 0x01	; 1
     efa:	90 93 9f 07 	sts	0x079F, r25	; 0x80079f <xTickCount+0x1>
     efe:	80 93 9e 07 	sts	0x079E, r24	; 0x80079e <xTickCount>
     f02:	80 91 9e 07 	lds	r24, 0x079E	; 0x80079e <xTickCount>
     f06:	90 91 9f 07 	lds	r25, 0x079F	; 0x80079f <xTickCount+0x1>
     f0a:	89 2b       	or	r24, r25
     f0c:	99 f5       	brne	.+102    	; 0xf74 <vTaskIncrementTick+0x94>
     f0e:	80 91 b6 07 	lds	r24, 0x07B6	; 0x8007b6 <pxDelayedTaskList>
     f12:	90 91 b7 07 	lds	r25, 0x07B7	; 0x8007b7 <pxDelayedTaskList+0x1>
     f16:	20 91 b4 07 	lds	r18, 0x07B4	; 0x8007b4 <pxOverflowDelayedTaskList>
     f1a:	30 91 b5 07 	lds	r19, 0x07B5	; 0x8007b5 <pxOverflowDelayedTaskList+0x1>
     f1e:	30 93 b7 07 	sts	0x07B7, r19	; 0x8007b7 <pxDelayedTaskList+0x1>
     f22:	20 93 b6 07 	sts	0x07B6, r18	; 0x8007b6 <pxDelayedTaskList>
     f26:	90 93 b5 07 	sts	0x07B5, r25	; 0x8007b5 <pxOverflowDelayedTaskList+0x1>
     f2a:	80 93 b4 07 	sts	0x07B4, r24	; 0x8007b4 <pxOverflowDelayedTaskList>
     f2e:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <xNumOfOverflows>
     f32:	8f 5f       	subi	r24, 0xFF	; 255
     f34:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <xNumOfOverflows>
     f38:	e0 91 b6 07 	lds	r30, 0x07B6	; 0x8007b6 <pxDelayedTaskList>
     f3c:	f0 91 b7 07 	lds	r31, 0x07B7	; 0x8007b7 <pxDelayedTaskList+0x1>
     f40:	80 81       	ld	r24, Z
     f42:	81 11       	cpse	r24, r1
     f44:	07 c0       	rjmp	.+14     	; 0xf54 <vTaskIncrementTick+0x74>
     f46:	8f ef       	ldi	r24, 0xFF	; 255
     f48:	9f ef       	ldi	r25, 0xFF	; 255
     f4a:	90 93 33 01 	sts	0x0133, r25	; 0x800133 <xNextTaskUnblockTime+0x1>
     f4e:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <xNextTaskUnblockTime>
     f52:	10 c0       	rjmp	.+32     	; 0xf74 <vTaskIncrementTick+0x94>
     f54:	e0 91 b6 07 	lds	r30, 0x07B6	; 0x8007b6 <pxDelayedTaskList>
     f58:	f0 91 b7 07 	lds	r31, 0x07B7	; 0x8007b7 <pxDelayedTaskList+0x1>
     f5c:	05 80       	ldd	r0, Z+5	; 0x05
     f5e:	f6 81       	ldd	r31, Z+6	; 0x06
     f60:	e0 2d       	mov	r30, r0
     f62:	06 80       	ldd	r0, Z+6	; 0x06
     f64:	f7 81       	ldd	r31, Z+7	; 0x07
     f66:	e0 2d       	mov	r30, r0
     f68:	82 81       	ldd	r24, Z+2	; 0x02
     f6a:	93 81       	ldd	r25, Z+3	; 0x03
     f6c:	90 93 33 01 	sts	0x0133, r25	; 0x800133 <xNextTaskUnblockTime+0x1>
     f70:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <xNextTaskUnblockTime>
     f74:	20 91 9e 07 	lds	r18, 0x079E	; 0x80079e <xTickCount>
     f78:	30 91 9f 07 	lds	r19, 0x079F	; 0x80079f <xTickCount+0x1>
     f7c:	80 91 32 01 	lds	r24, 0x0132	; 0x800132 <xNextTaskUnblockTime>
     f80:	90 91 33 01 	lds	r25, 0x0133	; 0x800133 <xNextTaskUnblockTime+0x1>
     f84:	28 17       	cp	r18, r24
     f86:	39 07       	cpc	r19, r25
     f88:	08 f4       	brcc	.+2      	; 0xf8c <vTaskIncrementTick+0xac>
     f8a:	66 c0       	rjmp	.+204    	; 0x1058 <vTaskIncrementTick+0x178>
     f8c:	e0 91 b6 07 	lds	r30, 0x07B6	; 0x8007b6 <pxDelayedTaskList>
     f90:	f0 91 b7 07 	lds	r31, 0x07B7	; 0x8007b7 <pxDelayedTaskList+0x1>
     f94:	80 81       	ld	r24, Z
     f96:	88 23       	and	r24, r24
     f98:	99 f0       	breq	.+38     	; 0xfc0 <vTaskIncrementTick+0xe0>
     f9a:	e0 91 b6 07 	lds	r30, 0x07B6	; 0x8007b6 <pxDelayedTaskList>
     f9e:	f0 91 b7 07 	lds	r31, 0x07B7	; 0x8007b7 <pxDelayedTaskList+0x1>
     fa2:	05 80       	ldd	r0, Z+5	; 0x05
     fa4:	f6 81       	ldd	r31, Z+6	; 0x06
     fa6:	e0 2d       	mov	r30, r0
     fa8:	c6 81       	ldd	r28, Z+6	; 0x06
     faa:	d7 81       	ldd	r29, Z+7	; 0x07
     fac:	8a 81       	ldd	r24, Y+2	; 0x02
     fae:	9b 81       	ldd	r25, Y+3	; 0x03
     fb0:	20 91 9e 07 	lds	r18, 0x079E	; 0x80079e <xTickCount>
     fb4:	30 91 9f 07 	lds	r19, 0x079F	; 0x80079f <xTickCount+0x1>
     fb8:	28 17       	cp	r18, r24
     fba:	39 07       	cpc	r19, r25
     fbc:	f8 f4       	brcc	.+62     	; 0xffc <vTaskIncrementTick+0x11c>
     fbe:	19 c0       	rjmp	.+50     	; 0xff2 <vTaskIncrementTick+0x112>
     fc0:	8f ef       	ldi	r24, 0xFF	; 255
     fc2:	9f ef       	ldi	r25, 0xFF	; 255
     fc4:	90 93 33 01 	sts	0x0133, r25	; 0x800133 <xNextTaskUnblockTime+0x1>
     fc8:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <xNextTaskUnblockTime>
     fcc:	45 c0       	rjmp	.+138    	; 0x1058 <vTaskIncrementTick+0x178>
     fce:	e0 91 b6 07 	lds	r30, 0x07B6	; 0x8007b6 <pxDelayedTaskList>
     fd2:	f0 91 b7 07 	lds	r31, 0x07B7	; 0x8007b7 <pxDelayedTaskList+0x1>
     fd6:	05 80       	ldd	r0, Z+5	; 0x05
     fd8:	f6 81       	ldd	r31, Z+6	; 0x06
     fda:	e0 2d       	mov	r30, r0
     fdc:	c6 81       	ldd	r28, Z+6	; 0x06
     fde:	d7 81       	ldd	r29, Z+7	; 0x07
     fe0:	8a 81       	ldd	r24, Y+2	; 0x02
     fe2:	9b 81       	ldd	r25, Y+3	; 0x03
     fe4:	20 91 9e 07 	lds	r18, 0x079E	; 0x80079e <xTickCount>
     fe8:	30 91 9f 07 	lds	r19, 0x079F	; 0x80079f <xTickCount+0x1>
     fec:	28 17       	cp	r18, r24
     fee:	39 07       	cpc	r19, r25
     ff0:	28 f4       	brcc	.+10     	; 0xffc <vTaskIncrementTick+0x11c>
     ff2:	90 93 33 01 	sts	0x0133, r25	; 0x800133 <xNextTaskUnblockTime+0x1>
     ff6:	80 93 32 01 	sts	0x0132, r24	; 0x800132 <xNextTaskUnblockTime>
     ffa:	2e c0       	rjmp	.+92     	; 0x1058 <vTaskIncrementTick+0x178>
     ffc:	8e 01       	movw	r16, r28
     ffe:	0e 5f       	subi	r16, 0xFE	; 254
    1000:	1f 4f       	sbci	r17, 0xFF	; 255
    1002:	c8 01       	movw	r24, r16
    1004:	fb d8       	rcall	.-3594   	; 0x1fc <vListRemove>
    1006:	8c 89       	ldd	r24, Y+20	; 0x14
    1008:	9d 89       	ldd	r25, Y+21	; 0x15
    100a:	89 2b       	or	r24, r25
    100c:	19 f0       	breq	.+6      	; 0x1014 <vTaskIncrementTick+0x134>
    100e:	ce 01       	movw	r24, r28
    1010:	0c 96       	adiw	r24, 0x0c	; 12
    1012:	f4 d8       	rcall	.-3608   	; 0x1fc <vListRemove>
    1014:	2e 89       	ldd	r18, Y+22	; 0x16
    1016:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxTopReadyPriority>
    101a:	82 17       	cp	r24, r18
    101c:	10 f4       	brcc	.+4      	; 0x1022 <vTaskIncrementTick+0x142>
    101e:	20 93 9c 07 	sts	0x079C, r18	; 0x80079c <uxTopReadyPriority>
    1022:	30 e0       	ldi	r19, 0x00	; 0
    1024:	c9 01       	movw	r24, r18
    1026:	88 0f       	add	r24, r24
    1028:	99 1f       	adc	r25, r25
    102a:	88 0f       	add	r24, r24
    102c:	99 1f       	adc	r25, r25
    102e:	88 0f       	add	r24, r24
    1030:	99 1f       	adc	r25, r25
    1032:	82 0f       	add	r24, r18
    1034:	93 1f       	adc	r25, r19
    1036:	b8 01       	movw	r22, r16
    1038:	86 53       	subi	r24, 0x36	; 54
    103a:	98 4f       	sbci	r25, 0xF8	; 248
    103c:	7d d8       	rcall	.-3846   	; 0x138 <vListInsertEnd>
    103e:	e0 91 b6 07 	lds	r30, 0x07B6	; 0x8007b6 <pxDelayedTaskList>
    1042:	f0 91 b7 07 	lds	r31, 0x07B7	; 0x8007b7 <pxDelayedTaskList+0x1>
    1046:	80 81       	ld	r24, Z
    1048:	81 11       	cpse	r24, r1
    104a:	c1 cf       	rjmp	.-126    	; 0xfce <vTaskIncrementTick+0xee>
    104c:	b9 cf       	rjmp	.-142    	; 0xfc0 <vTaskIncrementTick+0xe0>
    104e:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <uxMissedTicks>
    1052:	8f 5f       	subi	r24, 0xFF	; 255
    1054:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <uxMissedTicks>
    1058:	df 91       	pop	r29
    105a:	cf 91       	pop	r28
    105c:	1f 91       	pop	r17
    105e:	0f 91       	pop	r16
    1060:	08 95       	ret

00001062 <xTaskResumeAll>:
    1062:	cf 92       	push	r12
    1064:	df 92       	push	r13
    1066:	ef 92       	push	r14
    1068:	ff 92       	push	r15
    106a:	0f 93       	push	r16
    106c:	1f 93       	push	r17
    106e:	cf 93       	push	r28
    1070:	df 93       	push	r29
    1072:	0f b6       	in	r0, 0x3f	; 63
    1074:	f8 94       	cli
    1076:	0f 92       	push	r0
    1078:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <uxSchedulerSuspended>
    107c:	81 50       	subi	r24, 0x01	; 1
    107e:	80 93 9a 07 	sts	0x079A, r24	; 0x80079a <uxSchedulerSuspended>
    1082:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <uxSchedulerSuspended>
    1086:	81 11       	cpse	r24, r1
    1088:	5f c0       	rjmp	.+190    	; 0x1148 <xTaskResumeAll+0xe6>
    108a:	80 91 a0 07 	lds	r24, 0x07A0	; 0x8007a0 <uxCurrentNumberOfTasks>
    108e:	81 11       	cpse	r24, r1
    1090:	2f c0       	rjmp	.+94     	; 0x10f0 <xTaskResumeAll+0x8e>
    1092:	5d c0       	rjmp	.+186    	; 0x114e <xTaskResumeAll+0xec>
    1094:	d7 01       	movw	r26, r14
    1096:	15 96       	adiw	r26, 0x05	; 5
    1098:	ed 91       	ld	r30, X+
    109a:	fc 91       	ld	r31, X
    109c:	16 97       	sbiw	r26, 0x06	; 6
    109e:	c6 81       	ldd	r28, Z+6	; 0x06
    10a0:	d7 81       	ldd	r29, Z+7	; 0x07
    10a2:	ce 01       	movw	r24, r28
    10a4:	0c 96       	adiw	r24, 0x0c	; 12
    10a6:	aa d8       	rcall	.-3756   	; 0x1fc <vListRemove>
    10a8:	8e 01       	movw	r16, r28
    10aa:	0e 5f       	subi	r16, 0xFE	; 254
    10ac:	1f 4f       	sbci	r17, 0xFF	; 255
    10ae:	c8 01       	movw	r24, r16
    10b0:	a5 d8       	rcall	.-3766   	; 0x1fc <vListRemove>
    10b2:	2e 89       	ldd	r18, Y+22	; 0x16
    10b4:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxTopReadyPriority>
    10b8:	82 17       	cp	r24, r18
    10ba:	10 f4       	brcc	.+4      	; 0x10c0 <xTaskResumeAll+0x5e>
    10bc:	20 93 9c 07 	sts	0x079C, r18	; 0x80079c <uxTopReadyPriority>
    10c0:	30 e0       	ldi	r19, 0x00	; 0
    10c2:	c9 01       	movw	r24, r18
    10c4:	88 0f       	add	r24, r24
    10c6:	99 1f       	adc	r25, r25
    10c8:	88 0f       	add	r24, r24
    10ca:	99 1f       	adc	r25, r25
    10cc:	88 0f       	add	r24, r24
    10ce:	99 1f       	adc	r25, r25
    10d0:	82 0f       	add	r24, r18
    10d2:	93 1f       	adc	r25, r19
    10d4:	b8 01       	movw	r22, r16
    10d6:	86 53       	subi	r24, 0x36	; 54
    10d8:	98 4f       	sbci	r25, 0xF8	; 248
    10da:	2e d8       	rcall	.-4004   	; 0x138 <vListInsertEnd>
    10dc:	e0 91 ee 07 	lds	r30, 0x07EE	; 0x8007ee <pxCurrentTCB>
    10e0:	f0 91 ef 07 	lds	r31, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
    10e4:	9e 89       	ldd	r25, Y+22	; 0x16
    10e6:	86 89       	ldd	r24, Z+22	; 0x16
    10e8:	98 17       	cp	r25, r24
    10ea:	58 f0       	brcs	.+22     	; 0x1102 <xTaskResumeAll+0xa0>
    10ec:	dc 2c       	mov	r13, r12
    10ee:	09 c0       	rjmp	.+18     	; 0x1102 <xTaskResumeAll+0xa0>
    10f0:	d1 2c       	mov	r13, r1
    10f2:	0f 2e       	mov	r0, r31
    10f4:	fb ea       	ldi	r31, 0xAB	; 171
    10f6:	ef 2e       	mov	r14, r31
    10f8:	f7 e0       	ldi	r31, 0x07	; 7
    10fa:	ff 2e       	mov	r15, r31
    10fc:	f0 2d       	mov	r31, r0
    10fe:	cc 24       	eor	r12, r12
    1100:	c3 94       	inc	r12
    1102:	f7 01       	movw	r30, r14
    1104:	80 81       	ld	r24, Z
    1106:	81 11       	cpse	r24, r1
    1108:	c5 cf       	rjmp	.-118    	; 0x1094 <xTaskResumeAll+0x32>
    110a:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <uxMissedTicks>
    110e:	88 23       	and	r24, r24
    1110:	79 f0       	breq	.+30     	; 0x1130 <xTaskResumeAll+0xce>
    1112:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <uxMissedTicks>
    1116:	88 23       	and	r24, r24
    1118:	91 f0       	breq	.+36     	; 0x113e <xTaskResumeAll+0xdc>
    111a:	e2 de       	rcall	.-572    	; 0xee0 <vTaskIncrementTick>
    111c:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <uxMissedTicks>
    1120:	81 50       	subi	r24, 0x01	; 1
    1122:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <uxMissedTicks>
    1126:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <uxMissedTicks>
    112a:	81 11       	cpse	r24, r1
    112c:	f6 cf       	rjmp	.-20     	; 0x111a <xTaskResumeAll+0xb8>
    112e:	07 c0       	rjmp	.+14     	; 0x113e <xTaskResumeAll+0xdc>
    1130:	f1 e0       	ldi	r31, 0x01	; 1
    1132:	df 16       	cp	r13, r31
    1134:	21 f0       	breq	.+8      	; 0x113e <xTaskResumeAll+0xdc>
    1136:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <xMissedYield>
    113a:	81 30       	cpi	r24, 0x01	; 1
    113c:	39 f4       	brne	.+14     	; 0x114c <xTaskResumeAll+0xea>
    113e:	10 92 98 07 	sts	0x0798, r1	; 0x800798 <xMissedYield>
    1142:	c4 dc       	rcall	.-1656   	; 0xacc <vPortYield>
    1144:	81 e0       	ldi	r24, 0x01	; 1
    1146:	03 c0       	rjmp	.+6      	; 0x114e <xTaskResumeAll+0xec>
    1148:	80 e0       	ldi	r24, 0x00	; 0
    114a:	01 c0       	rjmp	.+2      	; 0x114e <xTaskResumeAll+0xec>
    114c:	80 e0       	ldi	r24, 0x00	; 0
    114e:	0f 90       	pop	r0
    1150:	0f be       	out	0x3f, r0	; 63
    1152:	df 91       	pop	r29
    1154:	cf 91       	pop	r28
    1156:	1f 91       	pop	r17
    1158:	0f 91       	pop	r16
    115a:	ff 90       	pop	r15
    115c:	ef 90       	pop	r14
    115e:	df 90       	pop	r13
    1160:	cf 90       	pop	r12
    1162:	08 95       	ret

00001164 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1164:	cf 93       	push	r28
    1166:	df 93       	push	r29
    1168:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    116a:	89 2b       	or	r24, r25
    116c:	91 f0       	breq	.+36     	; 0x1192 <vTaskDelay+0x2e>
		{
			vTaskSuspendAll();
    116e:	b2 de       	rcall	.-668    	; 0xed4 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1170:	80 91 9e 07 	lds	r24, 0x079E	; 0x80079e <xTickCount>
    1174:	90 91 9f 07 	lds	r25, 0x079F	; 0x80079f <xTickCount+0x1>
    1178:	c8 0f       	add	r28, r24
    117a:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    117c:	80 91 ee 07 	lds	r24, 0x07EE	; 0x8007ee <pxCurrentTCB>
    1180:	90 91 ef 07 	lds	r25, 0x07EF	; 0x8007ef <pxCurrentTCB+0x1>
    1184:	02 96       	adiw	r24, 0x02	; 2
    1186:	3a d8       	rcall	.-3980   	; 0x1fc <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1188:	ce 01       	movw	r24, r28
    118a:	53 dd       	rcall	.-1370   	; 0xc32 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    118c:	6a df       	rcall	.-300    	; 0x1062 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    118e:	81 11       	cpse	r24, r1
    1190:	01 c0       	rjmp	.+2      	; 0x1194 <vTaskDelay+0x30>
		{
			portYIELD_WITHIN_API();
    1192:	9c dc       	rcall	.-1736   	; 0xacc <vPortYield>
		}
	}
    1194:	df 91       	pop	r29
    1196:	cf 91       	pop	r28
    1198:	08 95       	ret

0000119a <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    119a:	0f 2e       	mov	r0, r31
    119c:	f2 ea       	ldi	r31, 0xA2	; 162
    119e:	ef 2e       	mov	r14, r31
    11a0:	f7 e0       	ldi	r31, 0x07	; 7
    11a2:	ff 2e       	mov	r15, r31
    11a4:	f0 2d       	mov	r31, r0

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    11a6:	ca ec       	ldi	r28, 0xCA	; 202
    11a8:	d7 e0       	ldi	r29, 0x07	; 7
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    11aa:	80 91 a1 07 	lds	r24, 0x07A1	; 0x8007a1 <uxTasksDeleted>
    11ae:	88 23       	and	r24, r24
    11b0:	39 f1       	breq	.+78     	; 0x1200 <prvIdleTask+0x66>
		{
			vTaskSuspendAll();
    11b2:	90 de       	rcall	.-736    	; 0xed4 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    11b4:	d7 01       	movw	r26, r14
    11b6:	1c 91       	ld	r17, X
			xTaskResumeAll();
    11b8:	54 df       	rcall	.-344    	; 0x1062 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    11ba:	11 23       	and	r17, r17
    11bc:	09 f1       	breq	.+66     	; 0x1200 <prvIdleTask+0x66>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    11be:	0f b6       	in	r0, 0x3f	; 63
    11c0:	f8 94       	cli
    11c2:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    11c4:	d7 01       	movw	r26, r14
    11c6:	15 96       	adiw	r26, 0x05	; 5
    11c8:	ed 91       	ld	r30, X+
    11ca:	fc 91       	ld	r31, X
    11cc:	16 97       	sbiw	r26, 0x06	; 6
    11ce:	06 81       	ldd	r16, Z+6	; 0x06
    11d0:	17 81       	ldd	r17, Z+7	; 0x07
					vListRemove( &( pxTCB->xGenericListItem ) );
    11d2:	c8 01       	movw	r24, r16
    11d4:	02 96       	adiw	r24, 0x02	; 2
    11d6:	12 d8       	rcall	.-4060   	; 0x1fc <vListRemove>
					--uxCurrentNumberOfTasks;
    11d8:	80 91 a0 07 	lds	r24, 0x07A0	; 0x8007a0 <uxCurrentNumberOfTasks>
    11dc:	81 50       	subi	r24, 0x01	; 1
    11de:	80 93 a0 07 	sts	0x07A0, r24	; 0x8007a0 <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
    11e2:	80 91 a1 07 	lds	r24, 0x07A1	; 0x8007a1 <uxTasksDeleted>
    11e6:	81 50       	subi	r24, 0x01	; 1
    11e8:	80 93 a1 07 	sts	0x07A1, r24	; 0x8007a1 <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
    11ec:	0f 90       	pop	r0
    11ee:	0f be       	out	0x3f, r0	; 63
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    11f0:	f8 01       	movw	r30, r16
    11f2:	87 89       	ldd	r24, Z+23	; 0x17
    11f4:	90 8d       	ldd	r25, Z+24	; 0x18
    11f6:	0e 94 89 00 	call	0x112	; 0x112 <vPortFree>
		vPortFree( pxTCB );
    11fa:	c8 01       	movw	r24, r16
    11fc:	0e 94 89 00 	call	0x112	; 0x112 <vPortFree>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    1200:	88 81       	ld	r24, Y
    1202:	82 30       	cpi	r24, 0x02	; 2
    1204:	90 f2       	brcs	.-92     	; 0x11aa <prvIdleTask+0x10>
			{
				taskYIELD();
    1206:	62 dc       	rcall	.-1852   	; 0xacc <vPortYield>
    1208:	d0 cf       	rjmp	.-96     	; 0x11aa <prvIdleTask+0x10>

0000120a <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    120a:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <uxSchedulerSuspended>
    120e:	81 11       	cpse	r24, r1
    1210:	13 c0       	rjmp	.+38     	; 0x1238 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1212:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxTopReadyPriority>
    1216:	90 e0       	ldi	r25, 0x00	; 0
    1218:	fc 01       	movw	r30, r24
    121a:	ee 0f       	add	r30, r30
    121c:	ff 1f       	adc	r31, r31
    121e:	ee 0f       	add	r30, r30
    1220:	ff 1f       	adc	r31, r31
    1222:	ee 0f       	add	r30, r30
    1224:	ff 1f       	adc	r31, r31
    1226:	8e 0f       	add	r24, r30
    1228:	9f 1f       	adc	r25, r31
    122a:	fc 01       	movw	r30, r24
    122c:	e6 53       	subi	r30, 0x36	; 54
    122e:	f8 4f       	sbci	r31, 0xF8	; 248
    1230:	80 81       	ld	r24, Z
    1232:	88 23       	and	r24, r24
    1234:	29 f0       	breq	.+10     	; 0x1240 <vTaskSwitchContext+0x36>
    1236:	1b c0       	rjmp	.+54     	; 0x126e <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1238:	81 e0       	ldi	r24, 0x01	; 1
    123a:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <xMissedYield>
    123e:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1240:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxTopReadyPriority>
    1244:	81 50       	subi	r24, 0x01	; 1
    1246:	80 93 9c 07 	sts	0x079C, r24	; 0x80079c <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    124a:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxTopReadyPriority>
    124e:	90 e0       	ldi	r25, 0x00	; 0
    1250:	fc 01       	movw	r30, r24
    1252:	ee 0f       	add	r30, r30
    1254:	ff 1f       	adc	r31, r31
    1256:	ee 0f       	add	r30, r30
    1258:	ff 1f       	adc	r31, r31
    125a:	ee 0f       	add	r30, r30
    125c:	ff 1f       	adc	r31, r31
    125e:	8e 0f       	add	r24, r30
    1260:	9f 1f       	adc	r25, r31
    1262:	fc 01       	movw	r30, r24
    1264:	e6 53       	subi	r30, 0x36	; 54
    1266:	f8 4f       	sbci	r31, 0xF8	; 248
    1268:	80 81       	ld	r24, Z
    126a:	88 23       	and	r24, r24
    126c:	49 f3       	breq	.-46     	; 0x1240 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    126e:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxTopReadyPriority>
    1272:	90 e0       	ldi	r25, 0x00	; 0
    1274:	9c 01       	movw	r18, r24
    1276:	22 0f       	add	r18, r18
    1278:	33 1f       	adc	r19, r19
    127a:	22 0f       	add	r18, r18
    127c:	33 1f       	adc	r19, r19
    127e:	22 0f       	add	r18, r18
    1280:	33 1f       	adc	r19, r19
    1282:	28 0f       	add	r18, r24
    1284:	39 1f       	adc	r19, r25
    1286:	d9 01       	movw	r26, r18
    1288:	a6 53       	subi	r26, 0x36	; 54
    128a:	b8 4f       	sbci	r27, 0xF8	; 248
    128c:	11 96       	adiw	r26, 0x01	; 1
    128e:	ed 91       	ld	r30, X+
    1290:	fc 91       	ld	r31, X
    1292:	12 97       	sbiw	r26, 0x02	; 2
    1294:	02 80       	ldd	r0, Z+2	; 0x02
    1296:	f3 81       	ldd	r31, Z+3	; 0x03
    1298:	e0 2d       	mov	r30, r0
    129a:	12 96       	adiw	r26, 0x02	; 2
    129c:	fc 93       	st	X, r31
    129e:	ee 93       	st	-X, r30
    12a0:	11 97       	sbiw	r26, 0x01	; 1
    12a2:	23 53       	subi	r18, 0x33	; 51
    12a4:	38 4f       	sbci	r19, 0xF8	; 248
    12a6:	e2 17       	cp	r30, r18
    12a8:	f3 07       	cpc	r31, r19
    12aa:	29 f4       	brne	.+10     	; 0x12b6 <vTaskSwitchContext+0xac>
    12ac:	22 81       	ldd	r18, Z+2	; 0x02
    12ae:	33 81       	ldd	r19, Z+3	; 0x03
    12b0:	fd 01       	movw	r30, r26
    12b2:	32 83       	std	Z+2, r19	; 0x02
    12b4:	21 83       	std	Z+1, r18	; 0x01
    12b6:	fc 01       	movw	r30, r24
    12b8:	ee 0f       	add	r30, r30
    12ba:	ff 1f       	adc	r31, r31
    12bc:	ee 0f       	add	r30, r30
    12be:	ff 1f       	adc	r31, r31
    12c0:	ee 0f       	add	r30, r30
    12c2:	ff 1f       	adc	r31, r31
    12c4:	8e 0f       	add	r24, r30
    12c6:	9f 1f       	adc	r25, r31
    12c8:	fc 01       	movw	r30, r24
    12ca:	e6 53       	subi	r30, 0x36	; 54
    12cc:	f8 4f       	sbci	r31, 0xF8	; 248
    12ce:	01 80       	ldd	r0, Z+1	; 0x01
    12d0:	f2 81       	ldd	r31, Z+2	; 0x02
    12d2:	e0 2d       	mov	r30, r0
    12d4:	86 81       	ldd	r24, Z+6	; 0x06
    12d6:	97 81       	ldd	r25, Z+7	; 0x07
    12d8:	90 93 ef 07 	sts	0x07EF, r25	; 0x8007ef <pxCurrentTCB+0x1>
    12dc:	80 93 ee 07 	sts	0x07EE, r24	; 0x8007ee <pxCurrentTCB>
    12e0:	08 95       	ret

000012e2 <__udivmodqi4>:
    12e2:	99 1b       	sub	r25, r25
    12e4:	79 e0       	ldi	r23, 0x09	; 9
    12e6:	04 c0       	rjmp	.+8      	; 0x12f0 <__udivmodqi4_ep>

000012e8 <__udivmodqi4_loop>:
    12e8:	99 1f       	adc	r25, r25
    12ea:	96 17       	cp	r25, r22
    12ec:	08 f0       	brcs	.+2      	; 0x12f0 <__udivmodqi4_ep>
    12ee:	96 1b       	sub	r25, r22

000012f0 <__udivmodqi4_ep>:
    12f0:	88 1f       	adc	r24, r24
    12f2:	7a 95       	dec	r23
    12f4:	c9 f7       	brne	.-14     	; 0x12e8 <__udivmodqi4_loop>
    12f6:	80 95       	com	r24
    12f8:	08 95       	ret

000012fa <memset>:
    12fa:	dc 01       	movw	r26, r24
    12fc:	01 c0       	rjmp	.+2      	; 0x1300 <memset+0x6>
    12fe:	6d 93       	st	X+, r22
    1300:	41 50       	subi	r20, 0x01	; 1
    1302:	50 40       	sbci	r21, 0x00	; 0
    1304:	e0 f7       	brcc	.-8      	; 0x12fe <memset+0x4>
    1306:	08 95       	ret

00001308 <strncpy>:
    1308:	fb 01       	movw	r30, r22
    130a:	dc 01       	movw	r26, r24
    130c:	41 50       	subi	r20, 0x01	; 1
    130e:	50 40       	sbci	r21, 0x00	; 0
    1310:	48 f0       	brcs	.+18     	; 0x1324 <strncpy+0x1c>
    1312:	01 90       	ld	r0, Z+
    1314:	0d 92       	st	X+, r0
    1316:	00 20       	and	r0, r0
    1318:	c9 f7       	brne	.-14     	; 0x130c <strncpy+0x4>
    131a:	01 c0       	rjmp	.+2      	; 0x131e <strncpy+0x16>
    131c:	1d 92       	st	X+, r1
    131e:	41 50       	subi	r20, 0x01	; 1
    1320:	50 40       	sbci	r21, 0x00	; 0
    1322:	e0 f7       	brcc	.-8      	; 0x131c <strncpy+0x14>
    1324:	08 95       	ret

00001326 <_exit>:
    1326:	f8 94       	cli

00001328 <__stop_program>:
    1328:	ff cf       	rjmp	.-2      	; 0x1328 <__stop_program>
